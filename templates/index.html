<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D Designer & LEGO Builder ‚Äî Open EA</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #0a0a0f;
            --bg2: #12121a;
            --bg3: #1a1a2e;
            --text: #e0e0e0;
            --text2: #888;
            --accent: #4f46e5;
            --accent2: #7c3aed;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border: #2a2a3e;
            --radius: 12px;
        }
        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', -apple-system, sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        /* === LAYOUT === */
        .app {
            display: grid;
            grid-template-columns: 280px 1fr 300px;
            grid-template-rows: 56px 0px 1fr 40px; /* header, toggle-bar(hidden on desktop), content, footer */
            height: 100vh;
        }
        .header {
            grid-column: 1 / -1;
            grid-row: 1;
        }
        .panel-toggle-bar {
            grid-column: 1 / -1;
            grid-row: 2;
        }
        .left-panel {
            grid-column: 1;
            grid-row: 3;
        }
        .viewport {
            grid-column: 2;
            grid-row: 3;
        }
        .right-panel {
            grid-column: 3;
            grid-row: 3;
        }
        .status-bar {
            grid-column: 1 / -1;
            grid-row: 4;
        }

        /* Desktop: ensure both panels always visible, hide toggle bar */
        @media screen and (min-width: 1025px) {
            .app {
                grid-template-rows: 56px 0px 1fr 40px;
                transition: grid-template-columns 0.3s ease;
            }
            .app.right-panel-hidden {
                grid-template-columns: 280px 1fr 0px;
            }
            .panel-toggle-bar {
                display: none !important;
            }
            .left-panel {
                display: block !important;
                position: static !important;
                width: auto !important;
                box-shadow: none !important;
            }
            .right-panel {
                display: block !important;
                position: static !important;
                width: auto !important;
                box-shadow: none !important;
                transition: opacity 0.3s ease, transform 0.3s ease;
                overflow: hidden;
            }
            .app.right-panel-hidden .right-panel {
                opacity: 0;
                transform: translateX(20px);
                pointer-events: none;
                padding: 0;
                border-left: none;
            }
        }

        /* Right panel desktop toggle button */
        .right-panel-toggle {
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
            z-index: 50;
            width: 28px;
            height: 60px;
            background: var(--bg2);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s;
            opacity: 0.6;
        }
        .right-panel-toggle:hover {
            opacity: 1;
            background: var(--bg3);
            color: var(--text);
        }
        .app.right-panel-hidden .right-panel-toggle {
            right: 12px;
        }
        @media screen and (max-width: 1024px) {
            .right-panel-toggle {
                display: none !important;
            }
        }

        /* === HEADER === */
        .header {
            grid-column: 1 / -1;
            background: var(--bg2);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 16px;
            z-index: 100;
        }
        .header .logo { font-size: 1.3em; font-weight: 700; }
        .header .logo span { color: var(--accent); }
        .header .mode-tabs {
            display: flex;
            gap: 4px;
            background: var(--bg);
            border-radius: 8px;
            padding: 3px;
            margin-left: 20px;
        }
        .mode-tab {
            padding: 6px 16px;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: var(--text2);
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.2s;
        }
        .mode-tab.active { background: var(--accent); color: white; }
        .mode-tab:hover:not(.active) { background: var(--bg3); color: var(--text); }

        .header-actions {
            margin-left: auto;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        /* === COGNITO AUTH === */
        .auth-section {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 12px;
            padding-left: 12px;
            border-left: 1px solid var(--border);
        }
        .btn-login {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            border: none;
            padding: 8px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        .btn-login:hover { transform: scale(1.05); box-shadow: 0 2px 12px rgba(79,70,229,0.4); }
        .user-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--bg3);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 4px 12px 4px 4px;
            cursor: pointer;
            position: relative;
        }
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 0.9em;
        }
        .user-name {
            color: var(--text);
            font-size: 0.85em;
            font-weight: 500;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .user-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--bg2);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            z-index: 200;
            min-width: 200px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }
        .user-menu.show { display: block; }
        .user-menu-item {
            padding: 10px 16px;
            color: var(--text);
            cursor: pointer;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s;
        }
        .user-menu-item:hover { background: var(--bg3); }
        .user-menu-item.danger { color: var(--danger); }
        .user-menu-divider { height: 1px; background: var(--border); }

        /* === MODAL OVERLAY === */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s;
        }
        .modal {
            background: var(--bg2);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        .modal h2 { margin-bottom: 16px; font-size: 1.2em; }
        .modal-close {
            float: right;
            background: none;
            border: none;
            color: var(--text2);
            font-size: 1.5em;
            cursor: pointer;
        }
        .modal-close:hover { color: var(--danger); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* === TAB PANELS === */
        .tab-bar {
            display: flex;
            gap: 2px;
            background: var(--bg);
            border-radius: 8px;
            padding: 3px;
            margin-bottom: 12px;
        }
        .tab-btn {
            flex: 1;
            padding: 6px 8px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: var(--text2);
            font-size: 0.78em;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .tab-btn.active { background: var(--accent); color: white; }
        .tab-btn:hover:not(.active) { background: var(--bg3); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* === INSTRUCTIONS PANEL === */
        .instruction-step {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }
        .instruction-step .step-num {
            display: inline-block;
            background: var(--accent);
            color: white;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            text-align: center;
            line-height: 28px;
            font-weight: 700;
            font-size: 0.85em;
            margin-right: 8px;
        }
        .instruction-step .step-desc { font-size: 0.85em; }
        .instruction-step .step-bricks {
            margin-top: 6px;
            font-size: 0.75em;
            color: var(--text2);
        }

        /* === PARTS LIST === */
        .parts-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: var(--bg);
            border-radius: 6px;
            margin-bottom: 4px;
            font-size: 0.8em;
        }
        .parts-count {
            background: var(--accent);
            color: white;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.8em;
            font-weight: 700;
        }

        /* === HELP OVERLAY === */
        .help-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .help-content {
            background: var(--bg2);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
        }
        .shortcut-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.88em;
        }
        .shortcut-key {
            background: var(--bg3);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 8px;
            font-family: monospace;
            font-size: 0.9em;
        }

        /* === BUTTONS === */
        .btn {
            padding: 7px 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg3);
            color: var(--text);
            cursor: pointer;
            font-size: 0.82em;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .btn:hover { background: var(--accent); border-color: var(--accent); color: white; }
        .btn-primary { background: var(--accent); border-color: var(--accent); color: white; }
        .btn-primary:hover { background: var(--accent2); }
        .btn-success { background: var(--success); border-color: var(--success); color: white; }
        .btn-success:hover { opacity: 0.85; }
        .btn-accent { background: linear-gradient(135deg, var(--accent), var(--accent2)); border-color: var(--accent); color: white; }
        .btn-accent:hover { opacity: 0.85; }
        .btn-danger { background: var(--danger); border-color: var(--danger); color: white; }
        .btn-warning { background: var(--warning); border-color: var(--warning); color: #000; }
        .btn-sm { padding: 4px 10px; font-size: 0.78em; }

        /* === LEFT PANEL === */
        .left-panel {
            background: var(--bg2);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            padding: 12px;
        }
        .panel-section { margin-bottom: 16px; }
        .panel-title {
            font-size: 0.75em;
            text-transform: uppercase;
            color: var(--text2);
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 8px;
            padding: 0 4px;
        }

        /* Brick palette */
        .brick-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }
        .brick-item {
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 8px 6px 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.7em;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        .brick-item:hover { border-color: var(--accent); transform: scale(1.05); box-shadow: 0 0 8px rgba(79,70,229,0.3); }
        .brick-item.selected { border-color: var(--accent); background: rgba(79,70,229,0.15); box-shadow: 0 0 12px rgba(79,70,229,0.4); }
        .brick-item .brick-icon { display: none; }
        .brick-item .brick-name { color: var(--text2); font-size: 0.85em; white-space: nowrap; }
        /* Visual LEGO brick preview */
        .brick-preview {
            display: inline-grid;
            gap: 1px;
            padding: 2px;
            border-radius: 4px;
            position: relative;
        }
        .brick-preview .stud {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%, rgba(255,255,255,0.4), transparent 60%);
            border: 1.5px solid rgba(0,0,0,0.25);
            box-shadow: inset 0 -1px 2px rgba(0,0,0,0.2), 0 1px 1px rgba(255,255,255,0.1);
        }
        .brick-preview.slope-preview {
            position: relative;
            overflow: hidden;
        }
        .brick-preview.slope-preview::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, transparent 40%, rgba(0,0,0,0.3) 100%);
            border-radius: 4px;
            pointer-events: none;
        }
        .brick-preview.round-preview .stud {
            width: 12px;
            height: 12px;
        }
        .brick-preview.flat-preview {
            opacity: 0.7;
            padding: 1px;
        }
        .brick-preview.flat-preview .stud {
            width: 9px;
            height: 9px;
        }
        .brick-type-badge {
            font-size: 0.65em;
            color: var(--text2);
            opacity: 0.6;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Minifig character gallery */
        .minifig-category-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        .minifig-cat-btn {
            padding: 2px 6px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text2);
            font-size: 0.65em;
            cursor: pointer;
            transition: all 0.2s;
        }
        .minifig-cat-btn:hover { border-color: var(--accent); color: var(--text); }
        .minifig-cat-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
        .minifig-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            max-height: 400px;
            overflow-y: auto;
        }
        .minifig-card {
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 6px 4px 4px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .minifig-card:hover { border-color: var(--accent); transform: scale(1.05); box-shadow: 0 0 10px rgba(79,70,229,0.3); }
        .minifig-card.selected { border-color: #f59e0b; background: rgba(245,158,11,0.12); box-shadow: 0 0 12px rgba(245,158,11,0.4); }
        .minifig-card .minifig-preview {
            width: 40px;
            height: 56px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .minifig-card .mf-head {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1.5px solid rgba(0,0,0,0.2);
            position: relative;
            z-index: 2;
        }
        .minifig-card .mf-headgear {
            width: 20px;
            height: 8px;
            border-radius: 4px 4px 0 0;
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
        }
        .minifig-card .mf-torso {
            width: 20px;
            height: 16px;
            border-radius: 2px;
            margin-top: -2px;
            position: relative;
            z-index: 1;
            border: 1px solid rgba(0,0,0,0.15);
        }
        .minifig-card .mf-arm-l, .minifig-card .mf-arm-r {
            width: 6px;
            height: 14px;
            border-radius: 3px;
            position: absolute;
            top: 0;
            z-index: 0;
        }
        .minifig-card .mf-arm-l { left: -5px; transform: rotate(5deg); }
        .minifig-card .mf-arm-r { right: -5px; transform: rotate(-5deg); }
        .minifig-card .mf-legs {
            width: 18px;
            height: 14px;
            display: flex;
            gap: 2px;
            margin-top: -1px;
        }
        .minifig-card .mf-leg {
            flex: 1;
            border-radius: 0 0 3px 3px;
            border: 1px solid rgba(0,0,0,0.12);
        }
        .minifig-card .mf-name {
            font-size: 0.6em;
            color: var(--text2);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 60px;
            line-height: 1.2;
        }
        .minifig-card .mf-cat {
            font-size: 0.5em;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Color palette */
        .color-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
        }
        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .color-swatch:hover { transform: scale(1.15); }
        .color-swatch.selected { border-color: white; box-shadow: 0 0 10px rgba(255,255,255,0.3); }

        /* Presets */
        .preset-list { display: flex; flex-direction: column; gap: 4px; }
        .preset-item {
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .preset-item:hover { border-color: var(--accent); background: rgba(79,70,229,0.1); }
        .preset-item .preset-name { font-weight: 600; font-size: 0.85em; }
        .preset-item .preset-desc { color: var(--text2); font-size: 0.75em; margin-top: 2px; }

        /* === VIEWPORT === */
        .viewport {
            position: relative;
            background: var(--bg);
            overflow: hidden;
        }
        #canvas3d {
            width: 100%;
            height: 100%;
            display: block;
        }
        .viewport-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 6px;
        }
        .viewport-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.75em;
            color: var(--text2);
        }
        .grid-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 6px;
        }

        /* === RIGHT PANEL === */
        .right-panel {
            background: var(--bg2);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            padding: 12px;
        }

        /* Properties */
        .prop-group { margin-bottom: 14px; }
        .prop-label { font-size: 0.72em; color: var(--text2); margin-bottom: 4px; font-weight: 600; }
        .prop-input {
            width: 100%;
            padding: 6px 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.82em;
        }
        .prop-input:focus { outline: none; border-color: var(--accent); }
        .prop-row { display: flex; gap: 6px; }
        .prop-row .prop-group { flex: 1; }

        /* Bambu export panel */
        .bambu-panel {
            background: linear-gradient(135deg, #1a1a2e, #0a2a1a);
            border: 1px solid var(--success);
            border-radius: var(--radius);
            padding: 14px;
            margin-top: 12px;
        }
        .bambu-panel h3 { font-size: 0.9em; color: var(--success); margin-bottom: 8px; }
        .bambu-info { font-size: 0.75em; color: var(--text2); line-height: 1.6; }
        .bambu-info strong { color: var(--text); }

        /* Layers list */
        .layer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: 4px;
            font-size: 0.78em;
            cursor: pointer;
        }
        .layer-item:hover { border-color: var(--accent); }
        .layer-item.selected { border-color: var(--accent); background: rgba(79,70,229,0.1); }
        .layer-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            flex-shrink: 0;
        }
        .layer-name { flex: 1; }
        .layer-delete {
            color: var(--danger);
            cursor: pointer;
            font-size: 1.1em;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .layer-item:hover .layer-delete { opacity: 1; }

        /* === STATUS BAR === */
        .statusbar {
            grid-column: 1 / -1;
            background: var(--bg2);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 0.72em;
            color: var(--text2);
            gap: 20px;
        }
        .status-item { display: flex; align-items: center; gap: 4px; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 60px;
            right: 20px;
            background: var(--bg3);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px 20px;
            font-size: 0.85em;
            z-index: 1000;
            animation: slideIn 0.3s ease;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        .toast.success { border-color: var(--success); }
        .toast.error { border-color: var(--danger); }
        @keyframes slideIn { from { transform: translateX(100px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* ========== iPad TOUCH TOOLBAR ========== */
        .touch-toolbar {
            display: none;
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg2);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 8px 12px;
            gap: 6px;
            z-index: 200;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95vw;
        }
        .touch-toolbar .touch-btn {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--bg3);
            color: var(--text);
            font-size: 1.2em;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .touch-toolbar .touch-btn:active,
        .touch-toolbar .touch-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            transform: scale(0.92);
        }
        .touch-toolbar .touch-btn .btn-label {
            font-size: 0.5em;
            display: block;
            margin-top: 1px;
            color: var(--text2);
        }

        /* Touch mode indicator */
        .touch-mode-indicator {
            display: none;
            position: fixed;
            top: 62px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent);
            color: white;
            padding: 4px 16px;
            border-radius: 0 0 10px 10px;
            font-size: 0.78em;
            font-weight: 700;
            z-index: 200;
            text-align: center;
        }

        /* Touch panel toggle buttons */
        .panel-toggle-bar {
            display: none;
            background: var(--bg2);
            border-bottom: 1px solid var(--border);
            padding: 6px 12px;
            z-index: 150;
            gap: 6px;
            justify-content: center;
            align-items: center;
        }
        .panel-toggle-bar .panel-toggle-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg3);
            color: var(--text);
            font-size: 0.82em;
            font-weight: 600;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .panel-toggle-bar .panel-toggle-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        /* ========== iPad MEDIA QUERIES ========== */

        /* iPad Mini (768x1024) and all smaller screens */
        @media screen and (max-width: 1024px) {
            .app {
                grid-template-columns: 1fr;
                grid-template-rows: 56px auto 1fr 40px;  /* header, toggle-bar, viewport, footer */
            }
            .header {
                grid-column: 1;
                grid-row: 1;
            }
            .left-panel,
            .right-panel {
                display: none;
                position: fixed;
                top: 96px;  /* header(56) + toggle-bar(40) */
                bottom: 50px;
                width: 300px;
                z-index: 300;
                box-shadow: 4px 0 30px rgba(0,0,0,0.5);
                overflow-y: auto;
                background: var(--bg2);
            }
            .left-panel {
                left: 0;
            }
            .right-panel {
                right: 0;
            }
            .left-panel.panel-open,
            .right-panel.panel-open {
                display: block;
                animation: slidePanel 0.3s ease;
            }
            @keyframes slidePanel {
                from { opacity: 0; transform: translateX(-30px); }
                to { opacity: 1; transform: translateX(0); }
            }
            .panel-toggle-bar {
                display: flex !important;
                position: static;
                grid-column: 1;
                grid-row: 2;
                z-index: 150;
            }
            .viewport {
                grid-column: 1;
                grid-row: 3;
            }
            .status-bar {
                grid-column: 1;
                grid-row: 4;
            }
            .header-actions {
                display: none;
            }
            .header .mode-tabs {
                margin-left: 8px;
            }
            .mode-tab {
                padding: 6px 10px;
                font-size: 0.78em;
            }
            .touch-toolbar {
                display: flex;
            }
            .touch-mode-indicator {
                display: block;
            }
            /* Make all interactive elements touch-friendly */
            .btn, .btn-sm, .tab-btn, .mode-tab, .brick-item, .color-swatch, .preset-item {
                min-height: 44px;
                min-width: 44px;
            }
            .btn-sm {
                padding: 10px 14px;
                font-size: 0.85em;
            }
            .brick-item {
                padding: 12px 6px;
            }
            .color-swatch {
                min-width: 40px;
                min-height: 40px;
            }
            .brick-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }
            .color-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 6px;
            }
            /* Viewport overlay buttons */
            .viewport-overlay .btn-sm,
            .grid-toggle .btn-sm {
                padding: 10px 14px;
                font-size: 0.85em;
                min-height: 44px;
            }
            .viewport-info {
                bottom: 56px;
                font-size: 0.82em;
                padding: 8px 14px;
            }
            .statusbar {
                font-size: 0.68em;
                padding: 0 8px;
                gap: 10px;
                overflow-x: auto;
            }
            .modal {
                width: 95%;
                max-height: 85vh;
                padding: 16px;
            }
            .toast {
                bottom: 110px;
                left: 50%;
                transform: translateX(-50%);
                right: auto;
            }
            /* Sliders need bigger touch target */
            input[type="range"] {
                height: 36px;
                -webkit-appearance: none;
                appearance: none;
                background: transparent;
            }
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 28px;
                height: 28px;
                border-radius: 50%;
                background: var(--accent);
                border: 2px solid white;
                cursor: pointer;
            }
            input[type="range"]::-webkit-slider-runnable-track {
                height: 6px;
                background: var(--border);
                border-radius: 3px;
            }
            select.prop-input {
                min-height: 44px;
                font-size: 0.9em;
            }
        }

        /* iPad Air (820x1180) & iPad 10th gen (810x1080) */
        @media screen and (min-width: 768px) and (max-width: 1024px) {
            .left-panel.panel-open,
            .right-panel.panel-open {
                width: 320px;
            }
            .touch-toolbar .touch-btn {
                width: 52px;
                height: 52px;
            }
        }

        /* iPad Pro 11" (834x1194) */
        @media screen and (min-width: 834px) and (max-width: 1194px) {
            .left-panel.panel-open,
            .right-panel.panel-open {
                width: 340px;
            }
        }

        /* iPad Pro 12.9" (1024x1366) ‚Äî landscape might fit 2-column */
        @media screen and (min-width: 1024px) and (max-width: 1366px) and (orientation: landscape) {
            .app {
                grid-template-columns: 260px 1fr;
                grid-template-rows: 56px auto 1fr 40px;
            }
            .left-panel {
                display: block !important;
                position: static;
                width: auto;
                box-shadow: none;
                grid-column: 1;
                grid-row: 3;
            }
            .viewport {
                grid-column: 2;
                grid-row: 3;
            }
            .right-panel {
                display: none;
                position: fixed;
                top: 56px;
                right: 0;
                bottom: 0;
                width: 300px;
                z-index: 300;
                box-shadow: -4px 0 30px rgba(0,0,0,0.5);
            }
            .right-panel.panel-open {
                display: block;
            }
            .panel-toggle-bar {
                display: flex;
                grid-column: 1 / -1;
                grid-row: 2;
            }
            .touch-toolbar {
                display: flex;
            }
            .touch-mode-indicator {
                display: block;
            }
            .header-actions {
                display: none;
            }
            .btn, .btn-sm {
                min-height: 44px;
            }
            .brick-item, .color-swatch {
                min-height: 44px;
                min-width: 44px;
            }
        }

        /* iPad landscape (any) */
        @media screen and (max-width: 1366px) and (orientation: landscape) and (hover: none) and (pointer: coarse) {
            .touch-toolbar {
                display: flex;
                bottom: 48px;
            }
            .touch-mode-indicator {
                display: block;
            }
        }

        /* iPad portrait (any) */
        @media screen and (max-width: 1024px) and (orientation: portrait) {
            .touch-toolbar {
                bottom: 48px;
            }
            .left-panel.panel-open,
            .right-panel.panel-open {
                width: 80vw;
                max-width: 360px;
            }
        }

        /* Panel overlay backdrop */
        .panel-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 250;
        }
        .panel-backdrop.visible {
            display: block;
        }

        /* Long-press visual feedback */
        .long-press-indicator {
            position: fixed;
            pointer-events: none;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--danger);
            z-index: 999;
            transform: translate(-50%, -50%);
            animation: longPressGrow 0.6s ease forwards;
        }
        @keyframes longPressGrow {
            from { width: 20px; height: 20px; opacity: 1; border-width: 3px; }
            to { width: 60px; height: 60px; opacity: 0.5; border-width: 2px; }
        }
    </style>
</head>
<body>
    <div class="app">
        <!-- HEADER -->
        <header class="header">
            <div class="logo">üß± <span>Open EA</span> 3D Designer</div>
            <div class="mode-tabs">
                <button class="mode-tab active" onclick="setMode('lego')">üß± LEGO</button>
                <button class="mode-tab" onclick="setMode('technic')">‚öôÔ∏è Technic</button>
                <button class="mode-tab" onclick="setMode('minifig')">üßë Minifig</button>
                <button class="mode-tab" onclick="setMode('3d')">üì¶ 3D</button>
            </div>
            <div class="header-actions">
                <button class="btn" onclick="undoAction()">‚è™ Undo</button>
                <button class="btn" onclick="redoAction()">‚è© Redo</button>
                <button class="btn" onclick="toggleMirrorMode()">ü™û Mirror</button>
                <button class="btn" onclick="duplicateSelected()">üìã Copy</button>
                <button class="btn" onclick="clearScene()">üóëÔ∏è Clear</button>
                <button class="btn btn-primary" onclick="saveDesign()">üíæ Save</button>
                <button class="btn" onclick="showInstructions()">üìñ Instructions</button>
                <button class="btn" onclick="showMeasurements()">üìè Measure</button>
                <button class="btn" onclick="showCostEstimate()">üí∞ Cost</button>
                <button class="btn" onclick="showImportDialog()">üì• Import</button>
                <button class="btn" onclick="takeScreenshot()">üì∏ Screenshot</button>
                <button class="btn" onclick="toggleTurntable()">üîÑ Spin</button>
                <button class="btn" onclick="shareDesign()">üîó Share</button>
                <button class="btn btn-success" onclick="exportSTL()">üì§ STL</button>
                <button class="btn btn-success" onclick="exportFor3MF()">üì¶ 3MF</button>
                <button class="btn btn-warning" onclick="showBambuPanel()">üñ®Ô∏è Bambu</button>
                <button class="btn" onclick="showHelp()" title="Keyboard Shortcuts">‚ùì</button>
                <button class="btn btn-accent" onclick="showPrinterHub()" title="3D Printer Hub">üñ®Ô∏è Printers</button>
                <button class="btn" onclick="showAIAssistant()" title="AI Design Assistant">ü§ñ AI</button>
                <button class="btn" onclick="playBuildAnimation()" title="Build Animation">üé¨ Animate</button>
                <button class="btn" onclick="checkStructure()" title="Structural Check">üèóÔ∏è Physics</button>
                <button class="btn" onclick="showCommunity()" title="Community Designs">üåç Community</button>
                <button class="btn" onclick="generateBuilding()" title="Generate Building">üè¢ Building</button>
                <button class="btn" onclick="showDecals()" title="Decals & Textures">üé≠ Decals</button>
                <button class="btn" onclick="generateInstructionBook()" title="Instruction Booklet">üìï Manual</button>
                <!-- Auth Section -->
                <div class="auth-section" id="auth-section">
                    <button class="btn-login" id="login-btn" onclick="cognitoLogin()">üîê Login</button>
                </div>
            </div>
        </header>

        <!-- PANEL TOGGLE BAR (for iPad/tablet ‚Äî shows as grid row 2) -->
        <div class="panel-toggle-bar" id="panel-toggle-bar">
            <button class="panel-toggle-btn" id="toggle-left-panel" onclick="togglePanel('left')">üß± Bricks</button>
            <button class="panel-toggle-btn" id="toggle-right-panel" onclick="togglePanel('right')">‚öôÔ∏è Settings</button>
            <button class="panel-toggle-btn" onclick="showHeaderActions()">üîß Tools</button>
        </div>

        <!-- LEFT PANEL - Brick Palette -->
        <aside class="left-panel">
            <!-- Tab bar for part categories -->
            <div class="tab-bar" id="parts-tab-bar">
                <button class="tab-btn active" onclick="showPartsTab('bricks')">üß± Bricks</button>
                <button class="tab-btn" onclick="showPartsTab('technic')">‚öôÔ∏è Technic</button>
                <button class="tab-btn" onclick="showPartsTab('minifig')">üßë Minifig</button>
            </div>

            <!-- Search -->
            <div style="margin-bottom:8px;">
                <input type="text" class="prop-input" id="brick-search" placeholder="üîç Search bricks..."
                       oninput="filterBricks(this.value)" style="font-size:0.82em;">
            </div>

            <!-- Bricks tab -->
            <div class="tab-content active" id="tab-bricks">
                <div class="panel-section" id="lego-panel">
                    <div class="panel-title">üß± LEGO Bricks</div>
                    <div class="brick-grid" id="brick-palette"></div>
                </div>
            </div>

            <!-- Technic tab -->
            <div class="tab-content" id="tab-technic">
                <div class="panel-section">
                    <div class="panel-title">‚öôÔ∏è Technic Parts</div>
                    <div class="brick-grid" id="technic-palette"></div>
                </div>
            </div>

            <!-- Minifig tab -->
            <div class="tab-content" id="tab-minifig">
                <div class="panel-section">
                    <div class="panel-title">ü¶∏ Characters</div>
                    <input type="text" class="search-input" id="minifig-search" placeholder="Search characters..." oninput="filterMinifigs(this.value)" style="margin-bottom:8px;">
                    <div class="minifig-category-tabs" id="minifig-cat-tabs">
                        <button class="minifig-cat-btn active" onclick="filterMinifigCat('all',this)">All</button>
                        <button class="minifig-cat-btn" onclick="filterMinifigCat('minecraft',this)">Minecraft</button>
                        <button class="minifig-cat-btn" onclick="filterMinifigCat('roblox',this)">Roblox</button>
                        <button class="minifig-cat-btn" onclick="filterMinifigCat('marvel',this)">Marvel</button>
                        <button class="minifig-cat-btn" onclick="filterMinifigCat('dc',this)">DC</button>
                        <button class="minifig-cat-btn" onclick="filterMinifigCat('starwars',this)">Star Wars</button>
                        <button class="minifig-cat-btn" onclick="filterMinifigCat('anime',this)">Anime</button>
                        <button class="minifig-cat-btn" onclick="filterMinifigCat('nintendo',this)">Nintendo</button>
                        <button class="minifig-cat-btn" onclick="filterMinifigCat('fortnite',this)">Fortnite</button>
                        <button class="minifig-cat-btn" onclick="filterMinifigCat('other',this)">Other</button>
                    </div>
                    <div class="minifig-grid" id="minifig-grid"></div>
                </div>
                <div class="panel-section">
                    <div class="panel-title">üßë Custom Builder</div>
                    <div id="minifig-builder">
                        <div class="prop-group">
                            <div class="prop-label">Hair/Hat</div>
                            <select class="prop-input" id="minifig-hair">
                                <option value="none">None</option>
                                <option value="hair_short">Short Hair</option>
                                <option value="hair_long">Long Hair</option>
                                <option value="hair_spiky">Spiky Hair</option>
                                <option value="helmet">Helmet</option>
                                <option value="mask">Mask</option>
                                <option value="hat_cap">Cap</option>
                                <option value="crown">Crown</option>
                            </select>
                        </div>
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;">
                            <div class="prop-group">
                                <div class="prop-label">Head</div>
                                <input type="color" id="minifig-head-color" value="#FFD500" style="width:100%;height:28px;border:1px solid #333;cursor:pointer;">
                            </div>
                            <div class="prop-group">
                                <div class="prop-label">Torso</div>
                                <input type="color" id="minifig-torso-color" value="#CC0000" style="width:100%;height:28px;border:1px solid #333;cursor:pointer;">
                            </div>
                            <div class="prop-group">
                                <div class="prop-label">Legs</div>
                                <input type="color" id="minifig-legs-color" value="#0055BF" style="width:100%;height:28px;border:1px solid #333;cursor:pointer;">
                            </div>
                            <div class="prop-group">
                                <div class="prop-label">Arms</div>
                                <input type="color" id="minifig-arms-color" value="#FFD500" style="width:100%;height:28px;border:1px solid #333;cursor:pointer;">
                            </div>
                        </div>
                        <button class="btn btn-primary" onclick="placeCustomMinifig()" style="width:100%;margin-top:8px;">üßë Place Custom Minifig</button>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">üé® Colors</div>
                <div class="color-grid" id="color-palette"></div>
                <div style="margin-top:8px;display:flex;gap:4px;">
                    <input type="color" id="custom-color" value="#CC0000"
                           style="width:36px;height:28px;border:none;cursor:pointer;background:transparent;"
                           onchange="selectCustomColor(this.value)"
                           title="Pick a custom color">
                    <input type="text" class="prop-input" id="hex-input" value="#CC0000"
                           placeholder="#hex" style="flex:1;font-size:0.78em;font-family:monospace;"
                           onchange="selectCustomColor(this.value)">
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">üü© Baseplate</div>
                <div style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:6px;">
                    <button class="btn btn-sm baseplate-color-btn" onclick="changeBaseplateColor(0x00A832, 0x00B835)" style="background:#00A832;width:28px;height:28px;border-radius:6px;border:2px solid transparent;" title="Classic Green"></button>
                    <button class="btn btn-sm baseplate-color-btn" onclick="changeBaseplateColor(0x4A90D9, 0x5AA0E5)" style="background:#4A90D9;width:28px;height:28px;border-radius:6px;border:2px solid transparent;" title="Blue"></button>
                    <button class="btn btn-sm baseplate-color-btn" onclick="changeBaseplateColor(0xC4A35A, 0xD4B36A)" style="background:#C4A35A;width:28px;height:28px;border-radius:6px;border:2px solid transparent;" title="Sand/Tan"></button>
                    <button class="btn btn-sm baseplate-color-btn" onclick="changeBaseplateColor(0x808080, 0x909090)" style="background:#808080;width:28px;height:28px;border-radius:6px;border:2px solid transparent;" title="Gray"></button>
                    <button class="btn btn-sm baseplate-color-btn" onclick="changeBaseplateColor(0x333333, 0x444444)" style="background:#333333;width:28px;height:28px;border-radius:6px;border:2px solid transparent;" title="Dark Gray"></button>
                    <button class="btn btn-sm baseplate-color-btn" onclick="changeBaseplateColor(0xFFFFFF, 0xEEEEEE)" style="background:#FFFFFF;width:28px;height:28px;border-radius:6px;border:2px solid transparent;" title="White"></button>
                </div>
                <div style="display:flex;gap:4px;align-items:center;">
                    <span style="font-size:0.75em;color:var(--text2);">Size:</span>
                    <select class="prop-input" id="baseplate-size-select" onchange="changeBaseplateSize(parseInt(this.value))" style="font-size:0.8em;flex:1;">
                        <option value="16">16√ó16 (Small)</option>
                        <option value="32" selected>32√ó32 (Standard)</option>
                        <option value="48">48√ó48 (Large)</option>
                    </select>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">‚≠ê Presets (<span id="preset-count">0</span>)</div>
                <div class="preset-list" id="preset-list"></div>
            </div>

            <div class="panel-section">
                <div class="panel-title">üíæ Saved Designs</div>
                <div id="saved-designs"></div>
            </div>
        </aside>

        <!-- VIEWPORT -->
        <main class="viewport">
            <canvas id="canvas3d"></canvas>
            <div class="viewport-overlay">
                <button class="btn btn-sm" onclick="resetCamera()">üè† Reset View</button>
                <button class="btn btn-sm" onclick="toggleGrid()">üìê Grid</button>
                <button class="btn btn-sm" onclick="toggleWireframe()">üî≤ Wireframe</button>
                <button class="btn btn-sm" onclick="toggleSnap()">üß≤ Snap: <span id="snap-status">ON</span></button>
            </div>
            <div class="viewport-info">
                <span id="brick-count">0 bricks</span> ¬∑
                <span id="dimensions">0 √ó 0 √ó 0 mm</span> ¬∑
                <span id="cursor-pos">X:0 Y:0 Z:0</span> ¬∑
                <button class="btn btn-sm" onclick="document.getElementById('kb-help').style.display = document.getElementById('kb-help').style.display === 'none' ? 'block' : 'none'" style="font-size:0.7em;padding:2px 8px;">? Keys</button>
            </div>
            <div id="kb-help" style="display:none;position:absolute;bottom:50px;left:50%;transform:translateX(-50%);background:rgba(10,10,20,0.95);border:1px solid var(--border);border-radius:12px;padding:16px 20px;font-size:0.8em;line-height:1.8;z-index:100;min-width:320px;color:#ccc;">
                <div style="font-weight:bold;color:#00ff88;margin-bottom:8px;font-size:1.1em;">Keyboard Controls</div>
                <div><kbd style="background:#333;padding:1px 6px;border-radius:4px;font-size:0.9em;">Arrow Keys</kbd> / <kbd style="background:#333;padding:1px 6px;border-radius:4px;font-size:0.9em;">W A S D</kbd> ‚Äî Move cursor on grid</div>
                <div><kbd style="background:#333;padding:1px 6px;border-radius:4px;font-size:0.9em;">Space</kbd> / <kbd style="background:#333;padding:1px 6px;border-radius:4px;font-size:0.9em;">Enter</kbd> ‚Äî Place brick at cursor</div>
                <div><kbd style="background:#333;padding:1px 6px;border-radius:4px;font-size:0.9em;">R</kbd> ‚Äî Rotate 90¬∞</div>
                <div><kbd style="background:#333;padding:1px 6px;border-radius:4px;font-size:0.9em;">Q</kbd> / <kbd style="background:#333;padding:1px 6px;border-radius:4px;font-size:0.9em;">E</kbd> ‚Äî Layer down / up</div>
                <div><kbd style="background:#333;padding:1px 6px;border-radius:4px;font-size:0.9em;">PgUp/PgDn</kbd> ‚Äî Jump 5 cells</div>
                <div><kbd style="background:#333;padding:1px 6px;border-radius:4px;font-size:0.9em;">Ctrl+Z</kbd> ‚Äî Undo</div>
                <div><kbd style="background:#333;padding:1px 6px;border-radius:4px;font-size:0.9em;">Delete</kbd> ‚Äî Remove selected</div>
                <div style="margin-top:8px;font-weight:bold;color:#00ff88;">Mouse Controls</div>
                <div><b>Click</b> ‚Äî Place brick</div>
                <div><b>Double-click</b> ‚Äî Move cursor (no place)</div>
                <div><b>Drag</b> ‚Äî Orbit camera</div>
                <div><b>Right-click</b> ‚Äî Delete brick</div>
                <div><b>Shift+click</b> ‚Äî Select brick</div>
            </div>
            <div class="grid-toggle">
                <button class="btn btn-sm" onclick="setView('front')">Front</button>
                <button class="btn btn-sm" onclick="setView('top')">Top</button>
                <button class="btn btn-sm" onclick="setView('side')">Side</button>
                <button class="btn btn-sm" onclick="setView('iso')">3D</button>
            </div>
            <button class="right-panel-toggle" id="right-panel-toggle" onclick="toggleRightPanel()" title="Toggle Settings Panel">‚óÄ</button>
        </main>

        <!-- RIGHT PANEL - Properties -->
        <aside class="right-panel">
            <div class="panel-section">
                <div class="panel-title">üìê Build Settings</div>
                <div class="prop-group">
                    <div class="prop-label">Build Height (Layer)</div>
                    <input type="range" class="prop-input" id="build-height" min="0" max="20" value="0"
                           oninput="setBuildHeight(this.value)">
                    <div style="font-size:0.75em;color:var(--text2);margin-top:2px;">Layer: <span id="height-display">0</span></div>
                </div>
                <div class="prop-group">
                    <div class="prop-label">Rotation</div>
                    <div class="prop-row">
                        <button class="btn btn-sm" onclick="rotateBrick(0)" style="flex:1">0¬∞</button>
                        <button class="btn btn-sm" onclick="rotateBrick(90)" style="flex:1">90¬∞</button>
                        <button class="btn btn-sm" onclick="rotateBrick(180)" style="flex:1">180¬∞</button>
                        <button class="btn btn-sm" onclick="rotateBrick(270)" style="flex:1">270¬∞</button>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">üì¶ Placed Bricks</div>
                <div id="brick-list"></div>
            </div>

            <div class="panel-section">
                <div class="panel-title">üîß Selected Brick</div>
                <div id="selected-props">
                    <div style="font-size:0.8em;color:var(--text2);">Click a brick to select</div>
                </div>
            </div>

            <!-- Bambu Lab Panel -->
            <div class="bambu-panel" id="bambu-panel" style="display:none;">
                <h3>üñ®Ô∏è Bambu Lab Print Settings</h3>
                <div class="bambu-info" id="bambu-info">
                    Click "üñ®Ô∏è Bambu Lab" to generate print settings.
                </div>
                <div style="margin-top:10px;display:flex;gap:6px;">
                    <button class="btn btn-success btn-sm" onclick="exportSTL()">üì§ Export STL</button>
                    <button class="btn btn-sm" onclick="exportFor3MF()">üì¶ Export 3MF</button>
                </div>
            </div>

            <div class="panel-section" style="margin-top:16px;">
                <div class="panel-title">üìã Design Info</div>
                <div class="prop-group">
                    <div class="prop-label">Design Name</div>
                    <input type="text" class="prop-input" id="design-name" value="My LEGO Design" placeholder="Name your design...">
                </div>
            </div>

            <!-- Mirror Mode Indicator -->
            <div class="panel-section" id="mirror-indicator" style="display:none;">
                <div style="background:linear-gradient(135deg,#1a1a2e,#2a1a2e);border:1px solid var(--accent2);border-radius:var(--radius);padding:10px;">
                    <div style="font-size:0.85em;font-weight:700;color:var(--accent2);">ü™û Mirror Mode: <span id="mirror-axis-display">X</span></div>
                    <div style="font-size:0.75em;color:var(--text2);margin-top:4px;">Bricks are mirrored along the axis</div>
                    <div style="display:flex;gap:4px;margin-top:6px;">
                        <button class="btn btn-sm" onclick="setMirrorAxis('x')">X Axis</button>
                        <button class="btn btn-sm" onclick="setMirrorAxis('y')">Y Axis</button>
                        <button class="btn btn-sm btn-danger" onclick="toggleMirrorMode()">Off</button>
                    </div>
                </div>
            </div>

            <!-- Quick Stats -->
            <div class="panel-section" style="margin-top:12px;">
                <div class="panel-title">üìä Quick Stats</div>
                <div id="quick-stats" style="font-size:0.78em;color:var(--text2);">
                    Click "üìè Measure" for detailed stats
                </div>
            </div>

            <!-- Lighting Presets -->
            <div class="panel-section" style="margin-top:12px;">
                <div class="panel-title">üí° Lighting</div>
                <div style="display:flex;flex-wrap:wrap;gap:4px;" id="lighting-presets">
                    <button class="btn btn-sm" onclick="setLighting('studio')" style="flex:1;min-width:70px">üé¨ Studio</button>
                    <button class="btn btn-sm" onclick="setLighting('daylight')" style="flex:1;min-width:70px">‚òÄÔ∏è Day</button>
                    <button class="btn btn-sm" onclick="setLighting('sunset')" style="flex:1;min-width:70px">üåÖ Sunset</button>
                    <button class="btn btn-sm" onclick="setLighting('night')" style="flex:1;min-width:70px">üåô Night</button>
                    <button class="btn btn-sm" onclick="setLighting('neon')" style="flex:1;min-width:70px">üîÆ Neon</button>
                    <button class="btn btn-sm" onclick="setLighting('warm')" style="flex:1;min-width:70px">üïØÔ∏è Warm</button>
                    <button class="btn btn-sm" onclick="setLighting('blueprint')" style="flex:1;min-width:70px">üìê Blueprint</button>
                    <button class="btn btn-sm" onclick="setLighting('photo_studio')" style="flex:1;min-width:70px">üì∏ Photo</button>
                </div>
            </div>

            <!-- Material Presets -->
            <div class="panel-section" style="margin-top:12px;">
                <div class="panel-title">üé® Material</div>
                <select class="prop-input" id="material-select" onchange="setMaterial(this.value)" style="font-size:0.8em;">
                    <option value="standard">Standard (Glossy ABS)</option>
                    <option value="matte">Matte</option>
                    <option value="chrome">Chrome (Metallic)</option>
                    <option value="pearl">Pearl (Shimmer)</option>
                    <option value="rubber">Rubber</option>
                    <option value="transparent">Transparent</option>
                    <option value="glow">Glow in Dark</option>
                    <option value="wood">Wood</option>
                </select>
            </div>

            <!-- Scene Templates -->
            <div class="panel-section" style="margin-top:12px;">
                <div class="panel-title">üé¨ Scene Templates</div>
                <div style="display:flex;flex-direction:column;gap:4px;" id="scene-templates">
                    <button class="btn btn-sm" onclick="loadScene('city_block')">üèôÔ∏è City Block</button>
                    <button class="btn btn-sm" onclick="loadScene('medieval')">üè∞ Medieval</button>
                    <button class="btn btn-sm" onclick="loadScene('space')">üöÄ Space Station</button>
                    <button class="btn btn-sm" onclick="loadScene('garden')">üå∏ Garden</button>
                    <button class="btn btn-sm" onclick="loadScene('animal_farm')">üêï Animal Farm</button>
                </div>
            </div>

            <!-- Assembly Animation -->
            <div class="panel-section" style="margin-top:12px;">
                <div class="panel-title">üé¨ Assembly Animation</div>
                <div style="display:flex;gap:4px;">
                    <button class="btn btn-sm btn-primary" onclick="playAssembly()" style="flex:1">‚ñ∂Ô∏è Play</button>
                    <button class="btn btn-sm" onclick="pauseAssembly()" style="flex:1">‚è∏Ô∏è Pause</button>
                    <button class="btn btn-sm btn-danger" onclick="stopAssembly()" style="flex:1">‚èπÔ∏è Stop</button>
                </div>
                <div style="margin-top:6px;">
                    <div class="prop-label">Speed</div>
                    <input type="range" class="prop-input" id="assembly-speed" min="0.2" max="3" step="0.1" value="1"
                           oninput="assemblySpeed=parseFloat(this.value)">
                </div>
                <div id="assembly-progress" style="font-size:0.75em;color:var(--text2);margin-top:4px;"></div>
            </div>

            <!-- Advanced Tools -->
            <div class="panel-section" style="margin-top:12px;">
                <div class="panel-title">üîß Advanced Tools</div>
                <div style="display:flex;flex-wrap:wrap;gap:4px;">
                    <button class="btn btn-sm" onclick="rotateDesign(90)" style="flex:1;min-width:80px">‚Üª Rotate 90¬∞</button>
                    <button class="btn btn-sm" onclick="explodeView()" style="flex:1;min-width:80px">üí• Explode</button>
                    <button class="btn btn-sm" onclick="randomizeColors()" style="flex:1;min-width:80px">üé≤ Random Colors</button>
                    <button class="btn btn-sm" onclick="showColorPalettes()" style="flex:1;min-width:80px">üé® Palettes</button>
                    <button class="btn btn-sm" onclick="checkSnap()" style="flex:1;min-width:80px">üîç Check Issues</button>
                    <button class="btn btn-sm" onclick="hollowDesign()" style="flex:1;min-width:80px">üï≥Ô∏è Hollow</button>
                </div>
            </div>

            <!-- Baseplate Options -->
            <div class="panel-section" style="margin-top:12px;">
                <div class="panel-title">üü© Baseplate</div>
                <select class="prop-input" id="baseplate-select" onchange="changeBaseplate(this.value)" style="font-size:0.8em;">
                    <option value="medium_green">Medium Green (32√ó32)</option>
                    <option value="small_green">Small Green (16√ó16)</option>
                    <option value="large_green">Large Green (48√ó48)</option>
                    <option value="medium_gray">Medium Gray (32√ó32)</option>
                    <option value="large_gray">Large Gray (48√ó48)</option>
                    <option value="small_tan">Sand/Tan (16√ó16)</option>
                    <option value="medium_blue">Blue (32√ó32)</option>
                    <option value="road">Road Plate (32√ó32)</option>
                    <option value="ocean">Ocean (32√ó32)</option>
                </select>
            </div>
        </aside>

        <!-- PANEL BACKDROP (for iPad) -->
        <div class="panel-backdrop" id="panel-backdrop" onclick="closeAllPanels()"></div>

        <!-- PANEL TOGGLE BAR moved to after header in grid -->

        <!-- TOUCH TOOLBAR (for iPad) -->
        <div class="touch-toolbar" id="touch-toolbar">
            <button class="touch-btn" onclick="touchAction('place')" id="touch-place-btn" title="Tap to Place">
                <div>üß±<div class="btn-label">Place</div></div>
            </button>
            <button class="touch-btn" onclick="touchAction('delete')" id="touch-delete-btn" title="Tap to Delete">
                <div>üóëÔ∏è<div class="btn-label">Delete</div></div>
            </button>
            <button class="touch-btn" onclick="touchAction('select')" id="touch-select-btn" title="Tap to Select">
                <div>üëÜ<div class="btn-label">Select</div></div>
            </button>
            <button class="touch-btn" onclick="touchAction('rotate')" id="touch-rotate-btn" title="Rotate Brick">
                <div>üîÑ<div class="btn-label">Rotate</div></div>
            </button>
            <button class="touch-btn" onclick="touchAction('layerUp')" id="touch-layerup-btn" title="Layer Up">
                <div>‚¨ÜÔ∏è<div class="btn-label">Up</div></div>
            </button>
            <button class="touch-btn" onclick="touchAction('layerDown')" id="touch-layerdown-btn" title="Layer Down">
                <div>‚¨áÔ∏è<div class="btn-label">Down</div></div>
            </button>
            <button class="touch-btn" onclick="touchAction('undo')" title="Undo">
                <div>‚Ü©Ô∏è<div class="btn-label">Undo</div></div>
            </button>
            <button class="touch-btn" onclick="touchAction('save')" title="Save">
                <div>üíæ<div class="btn-label">Save</div></div>
            </button>
            <button class="touch-btn" onclick="touchAction('camera')" title="Reset Camera">
                <div>üì∑<div class="btn-label">Camera</div></div>
            </button>
        </div>

        <!-- TOUCH MODE INDICATOR -->
        <div class="touch-mode-indicator" id="touch-mode-indicator">
            ‚úã Touch Mode: <span id="touch-mode-text">Place Brick</span>
        </div>

        <!-- STATUS BAR -->
        <footer class="statusbar">
            <div class="status-item">üß± Mode: <strong id="mode-display">LEGO</strong></div>
            <div class="status-item">üìê Snap: <strong id="snap-display">8mm grid</strong></div>
            <div class="status-item">üñ®Ô∏è Printer: <strong>Bambu Lab A1/P1S/X1C</strong></div>
            <div class="status-item">ü™û Mirror: <strong id="mirror-status">OFF</strong></div>
            <div class="status-item" style="margin-left:auto;">Open EA 3D Designer v3.0 | <span id="total-bricks-status">0</span> bricks</div>
        </footer>
    </div>

    <script>
    // ========== CORE STATE ==========
    const state = {
        mode: 'lego',
        selectedBrick: '2x4',
        selectedColor: '#CC0000',
        selectedColorName: 'red',
        buildHeight: 0,
        manualLayerMode: false, // true when user explicitly set layer via Q/E
        rotation: 0,
        snapEnabled: true,
        wireframe: false,
        showGrid: true,
        placedBricks: [],
        history: [],
        selectedPlacedBrick: null,
        // Grid cursor for keyboard-based placement
        cursorX: 16,  // center of 32-stud baseplate
        cursorZ: 16,
        cursorMode: false, // true = keyboard cursor active, false = mouse mode
        placementMode: 'brick', // 'brick', 'minifig', or 'preset'
        presetData: null,       // loaded preset bricks for stamp placement
        presetName: '',         // name of selected preset
    };

    let scene, camera, renderer, controls, raycaster, mouse;
    let gridHelper, groundPlane;
    let ghostBrick = null;
    let ghostMinifig = null;  // ghost preview for minifig placement
    let ghostPreset = null;   // ghost preview for preset stamp placement
    let cursorMarker = null;  // visual grid cursor
    let bricksGroup;
    let baseplateObj = null;
    let baseplateStuds = [];

    const UNIT = 8;     // 8mm per LEGO unit
    const HEIGHT = 9.6; // 9.6mm per brick height
    const PLATE_H = 3.2;
    const STUD_R = 2.4;
    const STUD_H = 1.7;

    // ========== INIT THREE.JS ==========
    function initThreeJS() {
        const canvas = document.getElementById('canvas3d');
        const rect = canvas.parentElement.getBoundingClientRect();

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0f);
        scene.fog = new THREE.Fog(0x0a0a0f, 300, 600);

        camera = new THREE.PerspectiveCamera(45, rect.width / rect.height, 0.1, 1000);
        camera.position.set(200, 120, 200);
        camera.lookAt(16 * UNIT, 0, 16 * UNIT);

        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(rect.width, rect.height);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(16 * UNIT, 0, 16 * UNIT);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.maxPolarAngle = Math.PI * 0.85;
        controls.minDistance = 20;
        controls.maxDistance = 500;

        // Mouse buttons: LEFT=rotate/orbit, MIDDLE=dolly/zoom, RIGHT=pan
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN
        };

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 80, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 200;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        const fillLight = new THREE.DirectionalLight(0x6666ff, 0.3);
        fillLight.position.set(-30, 40, -30);
        scene.add(fillLight);

        // Grid ‚Äî match baseplate size and position, semi-transparent so green baseplate shows through
        gridHelper = new THREE.GridHelper(32 * UNIT, 32, 0x005500, 0x004400);
        gridHelper.position.set(16 * UNIT, 0.15, 16 * UNIT);
        // GridHelper in r128 has an array of materials ‚Äî set transparency on each
        if (Array.isArray(gridHelper.material)) {
            gridHelper.material.forEach(m => { m.transparent = true; m.opacity = 0.4; m.depthWrite = false; });
        } else {
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.4;
            gridHelper.material.depthWrite = false;
        }
        scene.add(gridHelper);

        // Ground plane for raycasting (invisible ‚Äî only used for mouse intersection)
        const groundGeo = new THREE.PlaneGeometry(32 * UNIT + 100, 32 * UNIT + 100);
        const groundMat = new THREE.MeshBasicMaterial({
            transparent: true,
            opacity: 0,
            depthWrite: false,
            side: THREE.DoubleSide
        });
        groundPlane = new THREE.Mesh(groundGeo, groundMat);
        groundPlane.rotation.x = -Math.PI / 2;
        groundPlane.position.set(16 * UNIT, 0, 16 * UNIT);
        scene.add(groundPlane);

        // Baseplate visual (32x32 studs green baseplate)
        state.baseplateGridSize = 32;
        const baseplateGeo = new THREE.BoxGeometry(32 * UNIT, 1, 32 * UNIT);
        const baseplateMat = new THREE.MeshStandardMaterial({ color: 0x00A832, roughness: 0.6, metalness: 0.05 });
        baseplateObj = new THREE.Mesh(baseplateGeo, baseplateMat);
        baseplateObj.position.set(16 * UNIT, -0.5, 16 * UNIT);
        baseplateObj.receiveShadow = true;
        scene.add(baseplateObj);

        // Add studs on baseplate
        const studGeo = new THREE.CylinderGeometry(STUD_R, STUD_R, STUD_H, 8);
        const studMat = new THREE.MeshStandardMaterial({ color: 0x00B835, roughness: 0.5 });
        for(let x = 0; x < 32; x++) {
            for(let z = 0; z < 32; z++) {
                if((x + z) % 3 === 0) { // Show every 3rd stud for performance
                    const stud = new THREE.Mesh(studGeo, studMat);
                    stud.position.set(x * UNIT + UNIT/2, STUD_H/2, z * UNIT + UNIT/2);
                    scene.add(stud);
                }
            }
        }

        // Brick container
        bricksGroup = new THREE.Group();
        scene.add(bricksGroup);

        // Raycaster
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // Events ‚Äî use pointer events (same as OrbitControls) with capture to fire first
        let mouseDownPos = { x: 0, y: 0 };
        let mouseDownTime = 0;
        let clickTimer = null;
        let pendingClickEvent = null;
        canvas.addEventListener('pointerdown', (e) => {
            mouseDownPos = { x: e.clientX, y: e.clientY };
            mouseDownTime = Date.now();
        }, true);
        canvas.addEventListener('pointerup', (e) => {
            const dx = e.clientX - mouseDownPos.x;
            const dy = e.clientY - mouseDownPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const elapsed = Date.now() - mouseDownTime;
            // Only treat as a click if mouse barely moved AND was quick
            if (dist < 10 && elapsed < 500 && e.button === 0) {
                // Delay single click to distinguish from double-click
                if (clickTimer) clearTimeout(clickTimer);
                pendingClickEvent = e;
                clickTimer = setTimeout(() => {
                    if (pendingClickEvent) {
                        onCanvasClick(pendingClickEvent);
                        pendingClickEvent = null;
                    }
                }, 250);
            }
        }, true);
        canvas.addEventListener('dblclick', (e) => {
            // Cancel the pending single click ‚Äî this is a double-click (move cursor only)
            if (clickTimer) { clearTimeout(clickTimer); clickTimer = null; pendingClickEvent = null; }
            onCanvasDblClick(e);
        });
        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('contextmenu', onRightClick);
        window.addEventListener('resize', onResize);
        document.addEventListener('keydown', onKeyDown);

        // Create initial cursor marker
        createCursorMarker();

        animate();
    }

    // ========== BRICK GEOMETRY ==========
    function createBrickGeometry(brickType, color) {
        if (!window.brickData) return null;
        const info = window.brickData[brickType];
        if (!info) return null;

        const w = info.width * UNIT;
        const d = info.depth * UNIT;
        const h = info.height * HEIGHT;

        const group = new THREE.Group();

        // Main body ‚Äî centered at group origin (0, 0, 0)
        const bodyGeo = new THREE.BoxGeometry(w - 0.3, h - 0.3, d - 0.3);
        const bodyMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(color),
            roughness: 0.6,
            metalness: 0.1,
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.set(0, 0, 0);
        body.castShadow = true;
        body.receiveShadow = true;
        group.add(body);

        // Studs ‚Äî positioned relative to center
        const studGeo = new THREE.CylinderGeometry(STUD_R, STUD_R, STUD_H, 8);
        const studMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(color).multiplyScalar(1.1),
            roughness: 0.5,
            metalness: 0.2,
        });

        for(let sx = 0; sx < info.width; sx++) {
            for(let sz = 0; sz < info.depth; sz++) {
                const stud = new THREE.Mesh(studGeo, studMat);
                stud.position.set(
                    sx * UNIT + UNIT/2 - w/2,
                    h/2 + STUD_H/2,
                    sz * UNIT + UNIT/2 - d/2
                );
                stud.castShadow = true;
                group.add(stud);
            }
        }

        // Inner tube (visible from bottom, for visual quality)
        if(info.width >= 2 && info.depth >= 2) {
            const tubeGeo = new THREE.CylinderGeometry(3.2, 3.2, h - 1, 8, 1, true);
            const tubeMat = new THREE.MeshStandardMaterial({
                color: new THREE.Color(color).multiplyScalar(0.85),
                roughness: 0.7,
                side: THREE.DoubleSide,
            });
            for(let tx = 0; tx < info.width - 1; tx++) {
                for(let tz = 0; tz < info.depth - 1; tz++) {
                    const tube = new THREE.Mesh(tubeGeo, tubeMat);
                    tube.position.set(
                        (tx + 1) * UNIT - w/2,
                        0,
                        (tz + 1) * UNIT - d/2
                    );
                    group.add(tube);
                }
            }
        }

        return group;
    }

    function createGhostBrick() {
        if (ghostBrick) {
            scene.remove(ghostBrick);
        }
        if (!window.brickData) return;
        const info = window.brickData[state.selectedBrick];
        if (!info) return;

        const w = info.width * UNIT;
        const d = info.depth * UNIT;
        const h = info.height * HEIGHT;

        const geo = new THREE.BoxGeometry(w - 0.3, h - 0.3, d - 0.3);
        const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(state.selectedColor),
            transparent: true,
            opacity: 0.5,
            roughness: 0.6,
        });
        ghostBrick = new THREE.Mesh(geo, mat);
        // Apply rotation so you can see the brick orientation
        if (state.rotation !== 0) {
            ghostBrick.rotation.y = (state.rotation * Math.PI) / 180;
        }
        // For rotated bricks, swap visual width/depth for positioning
        const isRotated = (state.rotation === 90 || state.rotation === 270);
        const posW = isRotated ? d : w;
        const posD = isRotated ? w : d;
        ghostBrick.position.set(posW/2, h/2 + state.buildHeight * HEIGHT, posD/2);
        scene.add(ghostBrick);
    }

    // ========== GRID CURSOR SYSTEM ==========
    function createCursorMarker() {
        if (cursorMarker) scene.remove(cursorMarker);
        if (!window.brickData) return;
        const info = window.brickData[state.selectedBrick];
        if (!info) return;

        const isRotated = (state.rotation === 90 || state.rotation === 270);
        const w = isRotated ? info.depth * UNIT : info.width * UNIT;
        const d = isRotated ? info.width * UNIT : info.depth * UNIT;

        const group = new THREE.Group();

        // Bright outline rectangle on the ground showing cursor position
        const outlineGeo = new THREE.BufferGeometry();
        const hw = w / 2, hd = d / 2;
        const verts = new Float32Array([
            -hw, 0, -hd,  hw, 0, -hd,
            hw, 0, -hd,   hw, 0, hd,
            hw, 0, hd,    -hw, 0, hd,
            -hw, 0, hd,   -hw, 0, -hd,
            // Cross lines for visibility
            -hw, 0, -hd,  hw, 0, hd,
            hw, 0, -hd,   -hw, 0, hd,
        ]);
        outlineGeo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
        const outlineMat = new THREE.LineBasicMaterial({ color: 0x00ff88, linewidth: 2 });
        const outline = new THREE.LineSegments(outlineGeo, outlineMat);
        group.add(outline);

        // Pulsing filled rectangle (semi-transparent)
        const fillGeo = new THREE.PlaneGeometry(w, d);
        const fillMat = new THREE.MeshBasicMaterial({
            color: 0x00ff88, transparent: true, opacity: 0.15,
            side: THREE.DoubleSide, depthWrite: false
        });
        const fill = new THREE.Mesh(fillGeo, fillMat);
        fill.rotation.x = -Math.PI / 2;
        group.add(fill);

        // Calculate effective height for cursor display ‚Äî respect manual buildHeight
        const autoStack = getStackHeight(state.cursorX, state.cursorZ);
        const effectiveLayer = state.manualLayerMode ? state.buildHeight : autoStack;
        const h = info.height * HEIGHT;

        // Vertical line showing height from ground to placement level
        if (effectiveLayer > 0) {
            const poleGeo = new THREE.BufferGeometry();
            const poleVerts = new Float32Array([0, -effectiveLayer * HEIGHT, 0, 0, h, 0]);
            poleGeo.setAttribute('position', new THREE.BufferAttribute(poleVerts, 3));
            const poleMat = new THREE.LineBasicMaterial({ color: 0x00ff88 });
            const pole = new THREE.LineSegments(poleGeo, poleMat);
            group.add(pole);
        }

        const cx = state.cursorX * UNIT + w / 2;
        const cz = state.cursorZ * UNIT + d / 2;
        group.position.set(cx, effectiveLayer * HEIGHT + 0.3, cz);
        group.userData.isCursor = true;

        cursorMarker = group;
        scene.add(cursorMarker);
    }

    function updateCursorPosition() {
        if (!window.brickData) return;
        const info = window.brickData[state.selectedBrick];
        if (!info) return;
        const isRotated = (state.rotation === 90 || state.rotation === 270);
        const w = isRotated ? info.depth * UNIT : info.width * UNIT;
        const d = isRotated ? info.width * UNIT : info.depth * UNIT;

        // Clamp cursor to baseplate
        const maxX = isRotated ? 32 - info.depth : 32 - info.width;
        const maxZ = isRotated ? 32 - info.width : 32 - info.depth;
        state.cursorX = Math.max(0, Math.min(maxX, state.cursorX));
        state.cursorZ = Math.max(0, Math.min(maxZ, state.cursorZ));

        // Calculate effective layer ‚Äî respect manual buildHeight for gap placement
        const autoStack = getStackHeight(state.cursorX, state.cursorZ);
        const effectiveLayer = state.manualLayerMode ? state.buildHeight : autoStack;
        const hasCollision = checkCollision(state.cursorX, state.cursorZ, effectiveLayer);

        // Recreate cursor marker (to update size if brick type changed)
        createCursorMarker();

        // Move cursor marker to correct height
        if (cursorMarker) {
            const cx = state.cursorX * UNIT + w / 2;
            const cz = state.cursorZ * UNIT + d / 2;
            cursorMarker.position.set(cx, effectiveLayer * HEIGHT + 0.3, cz);
            // Red tint if collision, green if ok
            cursorMarker.traverse(child => {
                if (child.material && child.material.color) {
                    child.material.color.setHex(hasCollision ? 0xff4444 : 0x00ff88);
                }
            });
        }

        // Update ghost brick to cursor position at correct height
        if (state.placementMode === 'brick' && ghostBrick) {
            const h = info.height * HEIGHT;
            ghostBrick.position.set(
                state.cursorX * UNIT + w / 2,
                effectiveLayer * HEIGHT + h / 2,
                state.cursorZ * UNIT + d / 2
            );
            ghostBrick.rotation.y = (state.rotation * Math.PI) / 180;
            // Make ghost red if collision
            ghostBrick.material.color.setHex(hasCollision ? 0xff4444 : new THREE.Color(state.selectedColor).getHex());
            ghostBrick.material.opacity = hasCollision ? 0.3 : 0.5;
        }

        // Update ghost minifig to cursor position with rotation
        if (state.placementMode === 'minifig' && ghostMinifig) {
            const autoLayer = getStackHeight(state.cursorX, state.cursorZ);
            const mLayer = state.manualLayerMode && state.buildHeight > 0 ? state.buildHeight : autoLayer;
            ghostMinifig.position.set(
                state.cursorX * UNIT + UNIT / 2,
                mLayer * HEIGHT,
                state.cursorZ * UNIT + UNIT / 2
            );
            ghostMinifig.rotation.y = (state.rotation * Math.PI) / 180;
            // Show collision state ‚Äî make ghost red if occupied
            const minifigCollision = checkCollision(state.cursorX, state.cursorZ, mLayer);
            ghostMinifig.traverse(child => {
                if (child.isMesh && child.material) {
                    child.material.opacity = minifigCollision ? 0.25 : 0.5;
                }
            });
        }

        // Update status display ‚Äî show position, layer, and valid/blocked state
        const validLayers = findAllValidLayers(state.cursorX, state.cursorZ);
        const validCount = validLayers.length;
        const statusText = hasCollision
            ? `X:${state.cursorX} Z:${state.cursorZ} Layer:${effectiveLayer} BLOCKED (use Q/E to find gap, ${validCount} valid layers)`
            : `X:${state.cursorX} Z:${state.cursorZ} Layer:${effectiveLayer} OK (Q/E: change layer)`;
        document.getElementById('cursor-pos').textContent = statusText;
    }

    function moveCursor(dx, dz) {
        state.cursorMode = true;
        state.cursorX += dx;
        state.cursorZ += dz;
        updateCursorPosition();
        if (state.placementMode === 'preset') updateGhostPresetPosition();
    }

    function placeBrickAtCursor() {
        // If in preset mode, place the preset stamp
        if (state.placementMode === 'preset' && state.presetData) {
            placePresetAtCursor();
            updateGhostPresetPosition();
            updateCursorPosition();
            return;
        }
        // If in minifig mode, place the minifig instead
        if (state.placementMode === 'minifig' && selectedMinifig) {
            placeSelectedMinifig();
            updateGhostMinifig();
            updateCursorPosition();
            return;
        }
        const prevBrickCount = state.placedBricks.length;
        placeBrick(state.cursorX, state.cursorZ);
        const placed = state.placedBricks.length > prevBrickCount;

        if (placed) {
            // After placing, auto-advance to the NEXT valid layer at this position
            // This helps with stacking ‚Äî after placing at layer 0, go to layer 1 (or next gap)
            const newInfo = window.brickData ? window.brickData[state.selectedBrick] : null;
            const newH = newInfo ? (newInfo.height || 1) : 1;
            const nextLayer = state.buildHeight + newH;
            // Only auto-advance if the next layer is valid (not colliding)
            if (!checkCollision(state.cursorX, state.cursorZ, nextLayer)) {
                state.buildHeight = nextLayer;
            } else {
                // Try to find the next valid layer up
                const validUp = findNextValidLayerUp(state.cursorX, state.cursorZ, state.buildHeight);
                if (validUp > state.buildHeight) {
                    state.buildHeight = validUp;
                }
            }
            const el = document.getElementById('build-height');
            if (el) el.value = state.buildHeight;
            const disp = document.getElementById('height-display');
            if (disp) disp.textContent = state.buildHeight;
        }
        updateCursorPosition();
    }

    // ========== PLACE / REMOVE BRICKS ==========
    function getStackHeight(gridX, gridZ, rotationOverride) {
        // Find the highest brick that overlaps this grid position and return the next layer
        const newInfo = window.brickData ? window.brickData[state.selectedBrick] : null;
        const rot = (rotationOverride !== undefined) ? rotationOverride : state.rotation;
        const isRotated = (rot === 90 || rot === 270);
        // New brick footprint in grid units (account for rotation)
        const newW = newInfo ? (isRotated ? newInfo.depth : newInfo.width) : 1;
        const newD = newInfo ? (isRotated ? newInfo.width : newInfo.depth) : 1;

        let maxTop = 0;
        for (const brick of state.placedBricks) {
            const bInfo = window.brickData[brick.type];
            if (!bInfo) continue;

            const bx = brick.x;
            const bz = brick.y; // brick.y stores gridZ
            // Existing brick footprint (account for its rotation)
            const bRot = (brick.rotation === 90 || brick.rotation === 270);
            const bW = bRot ? bInfo.depth : bInfo.width;  // width along X axis
            const bD = bRot ? bInfo.width : bInfo.depth;  // depth along Z axis

            // Check if the new brick footprint overlaps with this existing brick
            const overlapX = gridX < bx + bW && gridX + newW > bx;
            const overlapZ = gridZ < bz + bD && gridZ + newD > bz;

            if (overlapX && overlapZ) {
                const topLayer = (brick.z || 0) + (bInfo.height || 1);
                if (topLayer > maxTop) maxTop = topLayer;
            }
        }
        return maxTop;
    }

    // Check if placing a brick at (gridX, gridZ, layer) would collide with any existing brick
    function checkCollision(gridX, gridZ, layer) {
        const newInfo = window.brickData ? window.brickData[state.selectedBrick] : null;
        if (!newInfo) return false;
        const isRotated = (state.rotation === 90 || state.rotation === 270);
        const newW = isRotated ? newInfo.depth : newInfo.width;
        const newD = isRotated ? newInfo.width : newInfo.depth;
        const newH = newInfo.height || 1;

        for (const brick of state.placedBricks) {
            const bInfo = window.brickData[brick.type];
            if (!bInfo) continue;

            const bx = brick.x;
            const bz = brick.y;
            const bLayer = brick.z || 0;
            const bRot = (brick.rotation === 90 || brick.rotation === 270);
            const bW = bRot ? bInfo.depth : bInfo.width;
            const bD = bRot ? bInfo.width : bInfo.depth;
            const bH = bInfo.height || 1;

            // Check XZ overlap
            const overlapX = gridX < bx + bW && gridX + newW > bx;
            const overlapZ = gridZ < bz + bD && gridZ + newD > bz;
            // Check vertical overlap (layer ranges intersect)
            const overlapY = layer < bLayer + bH && layer + newH > bLayer;

            if (overlapX && overlapZ && overlapY) {
                return true; // Collision detected!
            }
        }
        return false; // No collision
    }

    // Find the lowest valid (non-colliding) layer at this position
    // Searches from startLayer upward to find the first open spot
    function findLowestValidLayer(gridX, gridZ, startLayer) {
        startLayer = startLayer || 0;
        for (let l = startLayer; l <= 50; l++) {
            if (!checkCollision(gridX, gridZ, l)) return l;
        }
        return startLayer; // fallback
    }

    // Find all valid layers where a brick can be placed at this XZ position
    // Returns array of {layer, type} where type is 'ground', 'gap', 'top'
    function findAllValidLayers(gridX, gridZ) {
        const layers = [];
        const newInfo = window.brickData ? window.brickData[state.selectedBrick] : null;
        if (!newInfo) return layers;
        const newH = newInfo.height || 1;
        const topLayer = getStackHeight(gridX, gridZ);
        // Check every layer from 0 to just above the highest brick
        const maxCheck = topLayer + 5;
        for (let l = 0; l <= maxCheck; l++) {
            if (!checkCollision(gridX, gridZ, l)) {
                let type = 'gap';
                if (l === 0) type = 'ground';
                else if (l >= topLayer) type = 'top';
                layers.push({ layer: l, type });
            }
        }
        return layers;
    }

    // Find the next valid layer above the current one (for E key)
    function findNextValidLayerUp(gridX, gridZ, currentLayer) {
        for (let l = currentLayer + 1; l <= 50; l++) {
            if (!checkCollision(gridX, gridZ, l)) return l;
        }
        return currentLayer; // no valid layer found above
    }

    // Find the next valid layer below the current one (for Q key)
    function findNextValidLayerDown(gridX, gridZ, currentLayer) {
        for (let l = currentLayer - 1; l >= 0; l--) {
            if (!checkCollision(gridX, gridZ, l)) return l;
        }
        return currentLayer; // no valid layer found below
    }

    function placeBrick(gridX, gridZ, forceLayer) {
        if (!window.brickData) return;
        const info = window.brickData[state.selectedBrick];
        if (!info) return;

        const w = info.width * UNIT;
        const d = info.depth * UNIT;
        const h = info.height * HEIGHT;

        // Determine layer: forceLayer > buildHeight > auto-stack
        let layer;
        if (forceLayer !== undefined) {
            // Explicit layer requested
            layer = forceLayer;
        } else if (state.manualLayerMode) {
            // Manual layer set via Q/E ‚Äî respect it exactly (allows placing in gaps)
            layer = state.buildHeight;
        } else {
            // Auto-stack: find the lowest valid position at ground level or on top
            layer = getStackHeight(gridX, gridZ);
        }

        // Check collision at the chosen layer
        if (checkCollision(gridX, gridZ, layer)) {
            // Layer has a collision ‚Äî try to find a nearby valid layer
            // First try: the auto-stack top
            const autoLayer = getStackHeight(gridX, gridZ);
            if (autoLayer !== layer && !checkCollision(gridX, gridZ, autoLayer)) {
                layer = autoLayer;
            } else {
                // Second try: find the lowest valid layer from the requested position upward
                const validLayer = findLowestValidLayer(gridX, gridZ, layer);
                if (validLayer !== layer && !checkCollision(gridX, gridZ, validLayer)) {
                    layer = validLayer;
                } else {
                    showToast('Cannot place here ‚Äî brick overlaps!', 'error');
                    return;
                }
            }
        }

        const y = layer * HEIGHT;

        const brickGroup = createBrickGeometry(state.selectedBrick, state.selectedColor);
        if (!brickGroup) return;

        // Position at CENTER of grid cell footprint ‚Äî same as ghost brick
        // Swap width/depth when rotated 90/270
        const isRotated = (state.rotation === 90 || state.rotation === 270);
        const posW = isRotated ? d : w;
        const posD = isRotated ? w : d;

        // Center position = grid corner + half footprint
        const cx = gridX * UNIT + posW / 2;
        const cy = y + h / 2;
        const cz = gridZ * UNIT + posD / 2;

        brickGroup.position.set(cx, cy, cz);
        brickGroup.rotation.y = (state.rotation * Math.PI) / 180;

        brickGroup.userData = {
            type: state.selectedBrick,
            color: state.selectedColor,
            colorName: state.selectedColorName,
            gridX, gridZ,
            layer: layer,
            rotation: state.rotation,
            id: Date.now(),
        };

        bricksGroup.add(brickGroup);

        const brickData = {
            type: state.selectedBrick,
            x: gridX,
            y: gridZ,
            z: layer,
            color: state.selectedColorName,
            rotation: state.rotation,
            id: brickGroup.userData.id,
            mesh: brickGroup,
        };
        state.placedBricks.push(brickData);
        state.history.push({ action: 'add', brick: brickData });

        updateUI();
        showToast(`Placed ${info.name} (${state.selectedColorName})`, 'success');
    }

    function removeBrick(brickId) {
        const idx = state.placedBricks.findIndex(b => b.id === brickId);
        if (idx === -1) return;

        const brick = state.placedBricks[idx];
        // Remove from bricksGroup (bricks and minifigs both go here now)
        bricksGroup.remove(brick.mesh);
        // Also try scene removal for backward compat with old minifigs
        scene.remove(brick.mesh);
        state.placedBricks.splice(idx, 1);
        state.history.push({ action: 'remove', brick });
        state.selectedPlacedBrick = null;

        updateUI();
        showToast(brick.isMinifig ? 'Character removed' : 'Brick removed', 'success');
    }

    function undoAction() {
        const last = state.history.pop();
        if (!last) return;

        if (last.action === 'add') {
            bricksGroup.remove(last.brick.mesh);
            scene.remove(last.brick.mesh); // backward compat
            const idx = state.placedBricks.findIndex(b => b.id === last.brick.id);
            if (idx !== -1) state.placedBricks.splice(idx, 1);
        }
        updateUI();
        showToast('Undone!');
    }

    function clearScene() {
        if (!confirm('Clear all bricks?')) return;
        while(bricksGroup.children.length > 0) {
            bricksGroup.remove(bricksGroup.children[0]);
        }
        state.placedBricks = [];
        state.history = [];
        state.selectedPlacedBrick = null;
        updateUI();
        showToast('Scene cleared');
    }

    // ========== MOUSE / INPUT EVENTS ==========
    function onMouseMove(e) {
        const canvas = renderer.domElement;
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        // For preset/minifig mode, we don't need ghostBrick or brickData
        const isPresetMode = state.placementMode === 'preset';
        const isMinifigMode = state.placementMode === 'minifig';
        const info = (window.brickData && window.brickData[state.selectedBrick]) || null;

        // In brick mode, we need ghostBrick and info
        if (!isPresetMode && !isMinifigMode) {
            if (!ghostBrick || !info) return;
        }

        // Update ghost position ‚Äî check bricks AND ground plane
        raycaster.setFromCamera(mouse, camera);

        let hitPoint = null;

        // First check existing bricks (hover on top of a brick)
        const brickMeshes = [];
        bricksGroup.traverse(child => { if(child.isMesh) brickMeshes.push(child); });
        const brickHits = raycaster.intersectObjects(brickMeshes);
        if (brickHits.length > 0) {
            hitPoint = brickHits[0].point;
        }

        // Also check ground plane
        if (!hitPoint) {
            const groundHits = raycaster.intersectObject(groundPlane);
            if (groundHits.length > 0) {
                hitPoint = groundHits[0].point;
            }
        }

        if (hitPoint) {
            let gx = Math.floor(hitPoint.x / UNIT);
            let gz = Math.floor(hitPoint.z / UNIT);
            gx = Math.max(0, Math.min(31, gx));
            gz = Math.max(0, Math.min(31, gz));

            // Update cursor position to follow mouse (all modes need this)
            state.cursorX = gx;
            state.cursorZ = gz;

            // PRESET MODE: move ghost preset, hide ghost brick
            if (state.placementMode === 'preset') {
                if (ghostBrick) ghostBrick.visible = false;
                updateGhostPresetPosition();
                if (cursorMarker) {
                    cursorMarker.position.set(gx * UNIT + UNIT/2, 0.3, gz * UNIT + UNIT/2);
                    cursorMarker.traverse(child => {
                        if (child.material && child.material.color) child.material.color.setHex(0x00ff88);
                    });
                }
                document.getElementById('cursor-pos').textContent = `X:${gx} Z:${gz} [PRESET: ${state.presetName || ''}]`;
                return;
            }

            // MINIFIG MODE: move ghost minifig, hide ghost brick
            if (state.placementMode === 'minifig') {
                if (ghostBrick) ghostBrick.visible = false;
                if (typeof updateGhostMinifig === 'function') updateGhostMinifig();
                if (cursorMarker) {
                    cursorMarker.position.set(gx * UNIT + UNIT/2, 0.3, gz * UNIT + UNIT/2);
                }
                document.getElementById('cursor-pos').textContent = `X:${gx} Z:${gz} [MINIFIG: ${selectedMinifig || ''}]`;
                return;
            }

            // BRICK MODE: normal ghost brick positioning
            const w = info.width * UNIT;
            const d = info.depth * UNIT;
            const h = info.height * HEIGHT;

            // Swap width/depth for positioning when rotated 90¬∞ or 270¬∞
            const isRotated90 = (state.rotation === 90 || state.rotation === 270);
            const posW = isRotated90 ? d : w;
            const posD = isRotated90 ? w : d;

            const autoStack = getStackHeight(gx, gz);
            // Respect manual buildHeight for gap placement
            const effectiveLayer = state.manualLayerMode ? state.buildHeight : autoStack;
            const hasCollision = checkCollision(gx, gz, effectiveLayer);

            if (ghostBrick) ghostBrick.visible = true;
            ghostBrick.position.set(gx * UNIT + posW/2, effectiveLayer * HEIGHT + h/2, gz * UNIT + posD/2);
            ghostBrick.rotation.y = (state.rotation * Math.PI) / 180;
            // Red ghost if collision, normal color if ok
            ghostBrick.material.color.setHex(hasCollision ? 0xff4444 : new THREE.Color(state.selectedColor).getHex());
            ghostBrick.material.opacity = hasCollision ? 0.3 : 0.5;

            document.getElementById('cursor-pos').textContent = `X:${gx} Y:${gz} Layer:${effectiveLayer}${hasCollision ? ' (BLOCKED)' : ''}`;

            // Move cursor marker to match (at correct height)
            if (cursorMarker) {
                cursorMarker.position.set(gx * UNIT + posW/2, effectiveLayer * HEIGHT + 0.3, gz * UNIT + posD/2);
                cursorMarker.traverse(child => {
                    if (child.material && child.material.color) {
                        child.material.color.setHex(hasCollision ? 0xff4444 : 0x00ff88);
                    }
                });
            }
        }
    }

    // Helper: get grid position from mouse ray
    function getGridFromMouse(e) {
        const canvasEl = renderer.domElement;
        const rect = canvasEl.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        // Check bricks first, then ground
        const brickMeshes = [];
        bricksGroup.traverse(child => { if(child.isMesh) brickMeshes.push(child); });
        const brickHits = raycaster.intersectObjects(brickMeshes);
        if (brickHits.length > 0) {
            const pt = brickHits[0].point;
            return {
                gx: Math.max(0, Math.min(31, Math.floor(pt.x / UNIT))),
                gz: Math.max(0, Math.min(31, Math.floor(pt.z / UNIT))),
                hitBrick: true,
                brickHit: brickHits[0]
            };
        }
        const groundHits = raycaster.intersectObject(groundPlane);
        if (groundHits.length > 0) {
            const pt = groundHits[0].point;
            return {
                gx: Math.max(0, Math.min(31, Math.floor(pt.x / UNIT))),
                gz: Math.max(0, Math.min(31, Math.floor(pt.z / UNIT))),
                hitBrick: false
            };
        }
        return null;
    }

    function onCanvasClick(e) {
        const grid = getGridFromMouse(e);
        if (!grid) return;

        // Shift+click = select brick
        if (grid.hitBrick && e.shiftKey) {
            const clickedMesh = grid.brickHit.object;
            let parent = clickedMesh.parent;
            while(parent && !parent.userData.id) parent = parent.parent;
            if(parent && parent.userData.id) {
                selectPlacedBrick(parent.userData.id);
                return;
            }
        }

        // Update cursor position
        const samePos = (grid.gx === state.cursorX && grid.gz === state.cursorZ);
        state.cursorX = grid.gx;
        state.cursorZ = grid.gz;
        state.cursorMode = true;
        if (!samePos && !state.manualLayerMode) {
            state.buildHeight = 0;
        }

        // PRESET STAMP MODE: place entire preset design
        if (state.placementMode === 'preset' && state.presetData) {
            placePresetAtCursor();
            updateGhostPresetPosition();
            updateCursorPosition();
            return;
        }

        // MINIFIG MODE: place minifig instead of brick
        if (state.placementMode === 'minifig' && selectedMinifig) {
            placeSelectedMinifig();
            updateGhostMinifig();
            updateCursorPosition();
            return;
        }

        // BRICK MODE: normal brick placement
        const prevCount = state.placedBricks.length;
        placeBrick(grid.gx, grid.gz);
        const didPlace = state.placedBricks.length > prevCount;
        if (didPlace) {
            state.manualLayerMode = true;
            const newInfo = window.brickData ? window.brickData[state.selectedBrick] : null;
            const newH = newInfo ? (newInfo.height || 1) : 1;
            const nextLayer = state.buildHeight + newH;
            if (!checkCollision(grid.gx, grid.gz, nextLayer)) {
                state.buildHeight = nextLayer;
            } else {
                const validUp = findNextValidLayerUp(grid.gx, grid.gz, state.buildHeight);
                if (validUp > state.buildHeight) state.buildHeight = validUp;
            }
            const el = document.getElementById('build-height');
            if (el) el.value = state.buildHeight;
            const disp = document.getElementById('height-display');
            if (disp) disp.textContent = state.buildHeight;
        }
        updateCursorPosition();
    }

    // Double-click = move cursor WITHOUT placing (just reposition)
    function onCanvasDblClick(e) {
        e.preventDefault();
        const grid = getGridFromMouse(e);
        if (!grid) return;

        state.cursorX = grid.gx;
        state.cursorZ = grid.gz;
        state.cursorMode = true;
        updateCursorPosition();
        showToast(`Cursor moved to X:${grid.gx} Z:${grid.gz}`, 'info');
    }

    function onRightClick(e) {
        e.preventDefault();
        // Right-click to remove brick
        raycaster.setFromCamera(mouse, camera);
        const brickMeshes = [];
        bricksGroup.traverse(child => { if(child.isMesh) brickMeshes.push(child); });

        const intersects = raycaster.intersectObjects(brickMeshes);
        if(intersects.length > 0) {
            let parent = intersects[0].object.parent;
            while(parent && !parent.userData.id) parent = parent.parent;
            if(parent && parent.userData.id) {
                removeBrick(parent.userData.id);
            }
        }
    }

    function onKeyDown(e) {
        // Don't capture keys when typing in an input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        if(e.key === 'z' && e.ctrlKey) { undoAction(); e.preventDefault(); return; }
        if(e.key === 'Delete' && state.selectedPlacedBrick) { removeBrick(state.selectedPlacedBrick); return; }
        if(e.key === 'Escape') { switchToBrickMode(); showToast('Switched to brick mode', 'info'); return; }
        if(e.key === 'g') { toggleGrid(); return; }

        // === ARROW KEYS / WASD ‚Äî move cursor on grid ===
        if(e.key === 'ArrowLeft' || e.key === 'a') { moveCursor(-1, 0); e.preventDefault(); return; }
        if(e.key === 'ArrowRight' || e.key === 'd') { moveCursor(1, 0); e.preventDefault(); return; }
        if(e.key === 'ArrowUp' || e.key === 'w') { moveCursor(0, -1); e.preventDefault(); return; }
        if(e.key === 'ArrowDown' || e.key === 's') { moveCursor(0, 1); e.preventDefault(); return; }

        // === SPACE ‚Äî place brick at cursor position ===
        if(e.key === ' ') { placeBrickAtCursor(); e.preventDefault(); return; }

        // === ENTER ‚Äî also place brick ===
        if(e.key === 'Enter') { placeBrickAtCursor(); e.preventDefault(); return; }

        // === R ‚Äî rotate brick ===
        if(e.key === 'r') {
            state.rotation = (state.rotation + 90) % 360;
            if (state.placementMode === 'minifig') {
                // Update ghost minifig rotation
                if (ghostMinifig) ghostMinifig.rotation.y = (state.rotation * Math.PI) / 180;
            } else {
                createGhostBrick();
            }
            createCursorMarker();
            showToast(`Rotation: ${state.rotation}¬∞`);
            return;
        }

        // === Q/E ‚Äî layer up/down (smart: skips to next valid gap) ===
        if(e.key === 'q') {
            state.manualLayerMode = true; // entering manual layer control
            if (e.shiftKey) {
                // Shift+Q = go down by 1 (manual fine control, even into collisions)
                state.buildHeight = Math.max(0, state.buildHeight - 1);
            } else {
                // Q = find next valid layer DOWN (skip occupied layers)
                const newLayer = findNextValidLayerDown(state.cursorX, state.cursorZ, state.buildHeight);
                state.buildHeight = Math.max(0, newLayer);
            }
            document.getElementById('build-height').value = state.buildHeight;
            document.getElementById('height-display').textContent = state.buildHeight;
            updateCursorPosition();
            const hasCollision = checkCollision(state.cursorX, state.cursorZ, state.buildHeight);
            showToast(`Manual Layer: ${state.buildHeight}${hasCollision ? ' (occupied)' : ' (valid)'}`, hasCollision ? 'warning' : 'info');
            return;
        }
        if(e.key === 'e') {
            state.manualLayerMode = true; // entering manual layer control
            if (e.shiftKey) {
                // Shift+E = go up by 1 (manual fine control)
                state.buildHeight = Math.min(50, state.buildHeight + 1);
            } else {
                // E = find next valid layer UP (skip occupied layers)
                const newLayer = findNextValidLayerUp(state.cursorX, state.cursorZ, state.buildHeight);
                state.buildHeight = Math.min(50, newLayer);
            }
            document.getElementById('build-height').value = state.buildHeight;
            document.getElementById('height-display').textContent = state.buildHeight;
            updateCursorPosition();
            const hasCollision = checkCollision(state.cursorX, state.cursorZ, state.buildHeight);
            showToast(`Manual Layer: ${state.buildHeight}${hasCollision ? ' (occupied)' : ' (valid)'}`, hasCollision ? 'warning' : 'info');
            return;
        }

        // === 0 ‚Äî reset to auto-stack mode ===
        if(e.key === '0') {
            state.buildHeight = 0;
            state.manualLayerMode = false; // back to auto-stack
            document.getElementById('build-height').value = 0;
            document.getElementById('height-display').textContent = 0;
            updateCursorPosition();
            showToast('Auto-stack mode (layer auto-detects)', 'info');
            return;
        }

        // === Page Up / Page Down ‚Äî quick cursor jump (5 cells) ===
        if(e.key === 'PageUp') { moveCursor(0, -5); e.preventDefault(); return; }
        if(e.key === 'PageDown') { moveCursor(0, 5); e.preventDefault(); return; }
        if(e.key === 'Home') { moveCursor(-5, 0); e.preventDefault(); return; }
        if(e.key === 'End') { moveCursor(5, 0); e.preventDefault(); return; }
    }

    function selectPlacedBrick(brickId) {
        state.selectedPlacedBrick = brickId;
        const brick = state.placedBricks.find(b => b.id === brickId);
        if(brick) {
            const displayType = brick.isMinifig ? brick.type.replace('minifig_', 'Character: ') : brick.type;
            const colorVal = brick.mesh && brick.mesh.userData && brick.mesh.userData.color ? brick.mesh.userData.color : brick.color;
            const rotVal = brick.rotation !== undefined ? brick.rotation : 0;
            document.getElementById('selected-props').innerHTML = `
                <div class="prop-group"><div class="prop-label">Type</div><div style="font-size:0.85em">${displayType}</div></div>
                <div class="prop-group"><div class="prop-label">Position</div><div style="font-size:0.85em">X:${brick.x} Z:${brick.y} Layer:${brick.z}</div></div>
                <div class="prop-group"><div class="prop-label">Rotation</div><div style="font-size:0.85em">${rotVal}¬∞</div></div>
                <div class="prop-group"><div class="prop-label">Color</div><div style="font-size:0.85em;display:flex;align-items:center;gap:6px;"><span style="width:14px;height:14px;border-radius:4px;background:${colorVal};display:inline-block;"></span>${brick.color || ''}</div></div>
                <button class="btn btn-danger btn-sm" onclick="removeBrick(${brick.id})" style="margin-top:8px;width:100%;">üóëÔ∏è Delete</button>
            `;
        }
        updateBrickList();
    }

    function onResize() {
        const rect = renderer.domElement.parentElement.getBoundingClientRect();
        camera.aspect = rect.width / rect.height;
        camera.updateProjectionMatrix();
        renderer.setSize(rect.width, rect.height);
    }

    // ========== CAMERA VIEWS ==========
    function resetCamera() { camera.position.set(200, 120, 200); camera.lookAt(16 * UNIT, 0, 16 * UNIT); }
    function setView(view) {
        const c = { x: 64, y: 0, z: 64 };
        switch(view) {
            case 'front': camera.position.set(c.x, 30, 200); break;
            case 'top': camera.position.set(c.x, 150, c.z + 1); break;
            case 'side': camera.position.set(200, 30, c.z); break;
            case 'iso': camera.position.set(120, 80, 120); break;
        }
        camera.lookAt(c.x, c.y, c.z);
    }
    function toggleGrid() { gridHelper.visible = !gridHelper.visible; state.showGrid = !state.showGrid; }
    function toggleWireframe() { state.wireframe = !state.wireframe; bricksGroup.traverse(c => { if(c.material) c.material.wireframe = state.wireframe; }); }
    function toggleSnap() { state.snapEnabled = !state.snapEnabled; document.getElementById('snap-status').textContent = state.snapEnabled ? 'ON' : 'OFF'; document.getElementById('snap-display').textContent = state.snapEnabled ? '8mm grid' : 'Free'; }

    // ========== BASEPLATE OPTIONS ==========

    function changeBaseplateColor(plateColor, studColor) {
        // Find the baseplate mesh ‚Äî it's the green box
        scene.traverse(child => {
            if (child.isMesh && child.geometry.type === 'BoxGeometry' && child.material.color) {
                const c = child.material.color.getHex();
                // Match any previous baseplate color
                if (child === baseplateObj || child.receiveShadow && child.geometry.parameters.width === state.baseplateGridSize * UNIT) {
                    child.material.color.setHex(plateColor);
                    baseplateObj = child;
                }
            }
        });
        // If baseplateObj wasn't found by traversal, search more broadly
        if (!baseplateObj) {
            scene.traverse(child => {
                if (child.isMesh && child.geometry.type === 'BoxGeometry' && child.geometry.parameters.height === 1 && child.receiveShadow) {
                    child.material.color.setHex(plateColor);
                    baseplateObj = child;
                }
            });
        }
        // Update stud colors
        scene.traverse(child => {
            if (child.isMesh && child.geometry.type === 'CylinderGeometry' && child.geometry.parameters.height === STUD_H && !child.parent.userData.id) {
                child.material.color.setHex(studColor);
            }
        });
        // Highlight selected button
        document.querySelectorAll('.baseplate-color-btn').forEach(b => b.style.borderColor = 'transparent');
        event.target.style.borderColor = 'var(--accent)';
        showToast('Baseplate color changed', 'success');
    }

    function changeBaseplateSize(newSize) {
        const oldSize = state.baseplateGridSize || 32;
        state.baseplateGridSize = newSize;

        // Remove old baseplate, studs, and grid
        const toRemove = [];
        scene.traverse(child => {
            if (child === baseplateObj) toRemove.push(child);
            if (child.isMesh && child.geometry.type === 'CylinderGeometry' && child.geometry.parameters.height === STUD_H && !child.parent.userData.id) {
                toRemove.push(child);
            }
        });
        toRemove.forEach(obj => scene.remove(obj));

        // Remove old grid
        if (gridHelper) scene.remove(gridHelper);

        // Create new baseplate
        const bpGeo = new THREE.BoxGeometry(newSize * UNIT, 1, newSize * UNIT);
        const currentColor = baseplateObj ? baseplateObj.material.color.getHex() : 0x00A832;
        const bpMat = new THREE.MeshStandardMaterial({ color: currentColor, roughness: 0.6, metalness: 0.05 });
        baseplateObj = new THREE.Mesh(bpGeo, bpMat);
        baseplateObj.position.set(newSize * UNIT / 2, -0.5, newSize * UNIT / 2);
        baseplateObj.receiveShadow = true;
        scene.add(baseplateObj);

        // Create new studs
        const studGeo = new THREE.CylinderGeometry(STUD_R, STUD_R, STUD_H, 8);
        const studMat = new THREE.MeshStandardMaterial({ color: 0x00B835, roughness: 0.5 });
        for (let x = 0; x < newSize; x++) {
            for (let z = 0; z < newSize; z++) {
                if ((x + z) % 3 === 0) {
                    const stud = new THREE.Mesh(studGeo, studMat);
                    stud.position.set(x * UNIT + UNIT/2, STUD_H/2, z * UNIT + UNIT/2);
                    scene.add(stud);
                }
            }
        }

        // Create new grid
        gridHelper = new THREE.GridHelper(newSize * UNIT, newSize, 0x005500, 0x004400);
        gridHelper.position.set(newSize * UNIT / 2, 0.15, newSize * UNIT / 2);
        if (Array.isArray(gridHelper.material)) {
            gridHelper.material.forEach(m => { m.transparent = true; m.opacity = 0.4; m.depthWrite = false; });
        } else {
            gridHelper.material.transparent = true; gridHelper.material.opacity = 0.4; gridHelper.material.depthWrite = false;
        }
        scene.add(gridHelper);

        // Update ground plane
        groundPlane.geometry.dispose();
        groundPlane.geometry = new THREE.PlaneGeometry(newSize * UNIT + 100, newSize * UNIT + 100);
        groundPlane.position.set(newSize * UNIT / 2, 0, newSize * UNIT / 2);

        // Update camera target
        const center = newSize * UNIT / 2;
        controls.target.set(center, 0, center);
        camera.lookAt(center, 0, center);

        // Update cursor limits
        state.cursorX = Math.min(state.cursorX, newSize - 1);
        state.cursorZ = Math.min(state.cursorZ, newSize - 1);

        showToast(`Baseplate: ${newSize}√ó${newSize}`, 'success');
    }

    // ========== ANIMATION ==========
    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        // Pulse the cursor marker for visibility
        if (cursorMarker) {
            const t = Date.now() * 0.003;
            const pulse = 0.5 + 0.5 * Math.sin(t);
            cursorMarker.traverse(child => {
                if (child.material && child.material.opacity !== undefined && child.type === 'Mesh') {
                    child.material.opacity = 0.1 + 0.15 * pulse;
                }
                if (child.material && child.material.color && child.type === 'LineSegments') {
                    const g = 0.6 + 0.4 * pulse;
                    child.material.color.setRGB(0, g, 0.5);
                }
            });
        }

        renderer.render(scene, camera);
    }

    // ========== UI FUNCTIONS ==========
    function updateUI() {
        updateBrickCount();
        updateBrickList();
        updateDimensions();
    }

    function updateBrickCount() {
        document.getElementById('brick-count').textContent = `${state.placedBricks.length} bricks`;
    }

    function updateBrickList() {
        const list = document.getElementById('brick-list');
        if(state.placedBricks.length === 0) {
            list.innerHTML = '<div style="font-size:0.78em;color:var(--text2);">No bricks placed yet.<br>Click on the baseplate to place bricks!</div>';
            return;
        }
        list.innerHTML = state.placedBricks.slice(-20).reverse().map(b => `
            <div class="layer-item ${state.selectedPlacedBrick === b.id ? 'selected' : ''}" onclick="selectPlacedBrick(${b.id})">
                <div class="layer-color" style="background:${b.mesh.userData.color}"></div>
                <span class="layer-name">${b.type} [${b.x},${b.y},${b.z}]</span>
                <span class="layer-delete" onclick="event.stopPropagation();removeBrick(${b.id})">‚úï</span>
            </div>
        `).join('');
    }

    function updateDimensions() {
        if(state.placedBricks.length === 0) {
            document.getElementById('dimensions').textContent = '0 √ó 0 √ó 0 mm';
            return;
        }
        const bricks = state.placedBricks;
        const maxX = Math.max(...bricks.map(b => b.x + (window.brickData[b.type]?.depth || 4)));
        const maxY = Math.max(...bricks.map(b => b.y + (window.brickData[b.type]?.width || 2)));
        const maxZ = Math.max(...bricks.map(b => b.z + 1));
        document.getElementById('dimensions').textContent = `${(maxX * 8).toFixed(0)} √ó ${(maxY * 8).toFixed(0)} √ó ${(maxZ * 9.6).toFixed(0)} mm`;
    }

    function setBuildHeight(val) {
        state.buildHeight = parseInt(val);
        document.getElementById('height-display').textContent = val;
        createGhostBrick();
    }

    function rotateBrick(deg) {
        state.rotation = deg;
        createGhostBrick();
        showToast(`Rotation: ${deg}¬∞`);
    }

    function setMode(mode) {
        state.mode = mode;
        document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
        event.target.classList.add('active');
        document.getElementById('mode-display').textContent = mode === 'lego' ? 'LEGO' : '3D Model';
    }

    // ========== EMBEDDED BRICK DATA (for static/S3 hosting) ==========
    const EMBEDDED_BRICKS = {
        "1x1": {"width": 1, "depth": 1, "height": 1, "studs": 1, "name": "1\u00d71 Brick"},
        "1x2": {"width": 1, "depth": 2, "height": 1, "studs": 2, "name": "1\u00d72 Brick"},
        "1x3": {"width": 1, "depth": 3, "height": 1, "studs": 3, "name": "1\u00d73 Brick"},
        "1x4": {"width": 1, "depth": 4, "height": 1, "studs": 4, "name": "1\u00d74 Brick"},
        "1x6": {"width": 1, "depth": 6, "height": 1, "studs": 6, "name": "1\u00d76 Brick"},
        "1x8": {"width": 1, "depth": 8, "height": 1, "studs": 8, "name": "1\u00d78 Brick"},
        "2x2": {"width": 2, "depth": 2, "height": 1, "studs": 4, "name": "2\u00d72 Brick"},
        "2x3": {"width": 2, "depth": 3, "height": 1, "studs": 6, "name": "2\u00d73 Brick"},
        "2x4": {"width": 2, "depth": 4, "height": 1, "studs": 8, "name": "2\u00d74 Brick"},
        "2x6": {"width": 2, "depth": 6, "height": 1, "studs": 12, "name": "2\u00d76 Brick"},
        "2x8": {"width": 2, "depth": 8, "height": 1, "studs": 16, "name": "2\u00d78 Brick"},
        "2x10": {"width": 2, "depth": 10, "height": 1, "studs": 20, "name": "2\u00d710 Brick"},
        "1x1_flat": {"width": 1, "depth": 1, "height": 0.33, "studs": 1, "name": "1\u00d71 Plate"},
        "1x2_flat": {"width": 1, "depth": 2, "height": 0.33, "studs": 2, "name": "1\u00d72 Plate"},
        "2x2_flat": {"width": 2, "depth": 2, "height": 0.33, "studs": 4, "name": "2\u00d72 Plate"},
        "2x4_flat": {"width": 2, "depth": 4, "height": 0.33, "studs": 8, "name": "2\u00d74 Plate"},
        "1x1_round": {"width": 1, "depth": 1, "height": 1, "studs": 1, "name": "1\u00d71 Round Brick", "shape": "cylinder"},
        "2x2_round": {"width": 2, "depth": 2, "height": 1, "studs": 1, "name": "2\u00d72 Round Brick", "shape": "cylinder"},
        "1x2_slope": {"width": 1, "depth": 2, "height": 1, "studs": 1, "name": "1\u00d72 Slope", "shape": "slope"},
        "2x2_slope": {"width": 2, "depth": 2, "height": 1, "studs": 2, "name": "2\u00d72 Slope", "shape": "slope"},
        "2x4_slope": {"width": 2, "depth": 4, "height": 1, "studs": 4, "name": "2\u00d74 Slope", "shape": "slope"},
        "1x1_cone": {"width": 1, "depth": 1, "height": 1, "studs": 0, "name": "1\u00d71 Cone", "shape": "cone"},
        "2x2_dome": {"width": 2, "depth": 2, "height": 1, "studs": 0, "name": "2\u00d72 Dome", "shape": "dome"}
    };

    const EMBEDDED_COLORS = {
        "red": "#CC0000", "blue": "#0055BF", "yellow": "#FFD500",
        "green": "#237841", "black": "#1B2A34", "white": "#F4F4F4",
        "orange": "#FF7E14", "purple": "#81007B", "dark_blue": "#143044",
        "dark_green": "#184632", "brown": "#583927", "tan": "#DDC48E",
        "light_gray": "#9BA19D", "dark_gray": "#6D6E5C", "pink": "#FC97AC",
        "lime": "#BBE90B", "dark_red": "#720E0F", "dark_tan": "#958A73",
        "sand_blue": "#5A7184", "sand_green": "#789082", "medium_blue": "#5A93DB",
        "bright_light_orange": "#FFC700", "dark_orange": "#A95500",
        "bright_green": "#10CB31", "lavender": "#B9A0D2", "coral": "#FF698F",
        "medium_lavender": "#A06EB4", "dark_purple": "#3F1C5C",
        "bright_light_yellow": "#FFF03A", "sky_blue": "#7DBFDD",
        "aqua": "#B3D7D1", "medium_nougat": "#E3A05B"
    };

    // ========== LOAD DATA ==========
    async function loadBricks() {
        let data;
        try {
            const res = await fetch('/api/bricks');
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            data = await res.json();
            console.log('[INIT] Brick data loaded from API');
        } catch(e) {
            console.log('[INIT] API unavailable, using embedded brick data:', e.message);
            data = { bricks: EMBEDDED_BRICKS, colors: EMBEDDED_COLORS };
        }
        window.brickData = data.bricks;
        window.colorData = data.colors;

        // Render brick palette with visual previews
        const palette = document.getElementById('brick-palette');

        function createBrickPreviewHTML(key, info) {
            const w = info.width || 1;
            const d = info.depth || 1;
            const isFlat = key.includes('flat');
            const isSlope = key.includes('slope');
            const isRound = key.includes('round') || key.includes('cone') || key.includes('dome');
            const color = state.selectedColor || '#CC0000';

            let extraClass = '';
            if (isFlat) extraClass = ' flat-preview';
            else if (isSlope) extraClass = ' slope-preview';
            else if (isRound) extraClass = ' round-preview';

            let typeBadge = '';
            if (isFlat) typeBadge = '<span class="brick-type-badge">flat</span>';
            else if (isSlope) typeBadge = '<span class="brick-type-badge">slope</span>';
            else if (isRound) typeBadge = '<span class="brick-type-badge">round</span>';

            // Generate stud grid (depth = rows, width = cols)
            let studs = '';
            for (let r = 0; r < w; r++) {
                for (let c = 0; c < d; c++) {
                    studs += '<div class="stud"></div>';
                }
            }

            return `
                <div class="brick-preview${extraClass}" style="
                    grid-template-columns: repeat(${d}, 1fr);
                    background: ${color};
                    box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.15);
                ">${studs}</div>
                ${typeBadge}
            `;
        }

        palette.innerHTML = Object.entries(data.bricks).map(([key, info]) => `
            <div class="brick-item ${key === state.selectedBrick ? 'selected' : ''}" onclick="selectBrick('${key}')" data-brick-key="${key}">
                ${createBrickPreviewHTML(key, info)}
                <span class="brick-name">${info.name}</span>
            </div>
        `).join('');

        // Render color palette
        const colors = document.getElementById('color-palette');
        colors.innerHTML = Object.entries(data.colors).map(([name, hex]) => `
            <div class="color-swatch ${name === state.selectedColorName ? 'selected' : ''}"
                 style="background:${hex}" title="${name}"
                 onclick="selectColor('${name}', '${hex}')"></div>
        `).join('');

        createGhostBrick();
    }

    async function loadPresets() {
        try {
            const res = await fetch('/api/presets');
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();

            const list = document.getElementById('preset-list');
            const entries = Object.entries(data.presets);
            document.getElementById('preset-count').textContent = entries.length;
            list.innerHTML = entries.map(([key, p]) => `
                <div class="preset-item" style="display:flex;align-items:center;gap:8px;">
                    <div style="flex:1;cursor:pointer;" onclick="selectPresetForPlacement('${key}','${p.name.replace(/'/g,"\\'")}')">
                        <div class="preset-name">${p.name}</div>
                        <div class="preset-desc">${p.description} (${p.brick_count} bricks)</div>
                    </div>
                    <div style="display:flex;gap:4px;flex-shrink:0;">
                        <button onclick="event.stopPropagation();selectPresetForPlacement('${key}','${p.name.replace(/'/g,"\\'")}')" title="Select & Place" style="background:#4ecca3;color:#000;border:none;border-radius:6px;padding:4px 8px;cursor:pointer;font-size:11px;font-weight:bold;">üìçPlace</button>
                        <button onclick="event.stopPropagation();loadPreset('${key}')" title="Load (replaces scene)" style="background:#0f3460;color:#fff;border:none;border-radius:6px;padding:4px 8px;cursor:pointer;font-size:11px;">üìÇLoad</button>
                    </div>
                </div>
            `).join('');
        } catch(e) {
            console.log('[INIT] Presets API unavailable:', e.message);
            document.getElementById('preset-count').textContent = '0';
        }
    }

    async function loadPreset(name) {
        try {
            const res = await fetch(`/api/presets/${name}`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            if (!data.design) return;

            // Exit preset/minifig mode if active
            if (state.placementMode === 'preset') switchToBrickModeFromPreset();
            if (state.placementMode === 'minifig') switchToBrickMode();

            clearSceneSilent();
            for (const brick of data.design.bricks) {
                state.selectedBrick = brick.type;
                state.selectedColor = window.colorData[brick.color] || '#CC0000';
                state.selectedColorName = brick.color;
                state.buildHeight = brick.z || 0;
                state.rotation = brick.rotation || 0;
                placeBrick(brick.x || 0, brick.y || 0);
            }
            state.selectedBrick = '2x4';
            state.selectedColor = '#CC0000';
            state.selectedColorName = 'red';
            state.buildHeight = 0;
            state.rotation = 0;
            createGhostBrick();
            document.getElementById('design-name').value = data.design.name;
            showToast(`Loaded: ${data.design.name}`, 'success');
        } catch(e) {
            console.error('Failed to load preset:', e);
            showToast('Could not load preset ‚Äî API unavailable', 'error');
        }
    }

    // ========== PRESET STAMP PLACEMENT ==========
    async function selectPresetForPlacement(presetKey, presetName) {
        try {
            const res = await fetch(`/api/presets/${presetKey}`);
            const data = await res.json();
            if (!data.design || !data.design.bricks || data.design.bricks.length === 0) {
                showToast('Preset has no bricks', 'error');
                return;
            }
            // Normalize bricks ‚Äî find min x,z to offset to 0,0
            const bricks = data.design.bricks.map(b => ({
                type: b.type || '2x4',
                color: b.color || 'red',
                x: b.x || 0,
                y: b.y || 0,
                z: b.z || 0,
                rotation: b.rotation || 0
            }));
            const minX = Math.min(...bricks.map(b => b.x));
            const minZ = Math.min(...bricks.map(b => b.y));
            bricks.forEach(b => { b.x -= minX; b.y -= minZ; });

            state.presetData = bricks;
            state.presetName = presetName || presetKey;
            state.placementMode = 'preset';
            state.buildHeight = 0;
            state.manualLayerMode = false;

            // Hide ghost brick and ghost minifig
            if (ghostBrick) { ghostBrick.visible = false; }
            if (ghostMinifig) { scene.remove(ghostMinifig); ghostMinifig = null; }

            createGhostPreset();
            updateGhostPresetPosition();
            updateModeIndicator();
            showToast(`Selected: ${state.presetName} ‚Äî click to place!`, 'success');
        } catch(e) {
            showToast('Failed to load preset', 'error');
        }
    }

    function createGhostPreset() {
        // Remove old ghost preset
        if (ghostPreset) { scene.remove(ghostPreset); ghostPreset = null; }
        if (!state.presetData || state.placementMode !== 'preset') return;

        ghostPreset = new THREE.Group();
        const UNIT = 8, HEIGHT = 9.6;

        for (const brick of state.presetData) {
            const info = window.brickData ? window.brickData[brick.type] : null;
            if (!info) continue;

            const bw = info.width * UNIT;
            const bd = info.depth * UNIT;
            const bh = (info.height || 1) * HEIGHT;
            const isRotated = (brick.rotation === 90 || brick.rotation === 270);
            const posW = isRotated ? bd : bw;
            const posD = isRotated ? bw : bd;

            const color = window.colorData ? (window.colorData[brick.color] || '#CC0000') : '#CC0000';
            const geo = new THREE.BoxGeometry(posW - 0.5, bh - 0.5, posD - 0.5);
            const mat = new THREE.MeshPhongMaterial({
                color: color,
                transparent: true,
                opacity: 0.5,
                depthWrite: false
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(
                brick.x * UNIT + posW / 2,
                brick.z * HEIGHT + bh / 2,
                brick.y * UNIT + posD / 2
            );
            ghostPreset.add(mesh);

            // Add studs on top
            const studR = 2.4, studH = 1.8;
            const studGeo = new THREE.CylinderGeometry(studR, studR, studH, 8);
            const studMat = new THREE.MeshPhongMaterial({ color: color, transparent: true, opacity: 0.5 });
            const sw = isRotated ? info.depth : info.width;
            const sd = isRotated ? info.width : info.depth;
            for (let sx = 0; sx < sw; sx++) {
                for (let sz = 0; sz < sd; sz++) {
                    const stud = new THREE.Mesh(studGeo, studMat);
                    stud.position.set(
                        brick.x * UNIT + sx * UNIT + UNIT / 2,
                        brick.z * HEIGHT + bh + studH / 2,
                        brick.y * UNIT + sz * UNIT + UNIT / 2
                    );
                    ghostPreset.add(stud);
                }
            }
        }
        scene.add(ghostPreset);
    }

    function updateGhostPresetPosition() {
        if (!ghostPreset || state.placementMode !== 'preset') return;
        const UNIT = 8;
        ghostPreset.position.set(
            state.cursorX * UNIT,
            0,
            state.cursorZ * UNIT
        );
    }

    function placePresetAtCursor() {
        if (!state.presetData || state.placementMode !== 'preset') return;

        const offsetX = state.cursorX;
        const offsetZ = state.cursorZ;
        let placedCount = 0;

        // Save current state to restore after
        const savedBrick = state.selectedBrick;
        const savedColor = state.selectedColor;
        const savedColorName = state.selectedColorName;
        const savedHeight = state.buildHeight;
        const savedRotation = state.rotation;
        const savedManual = state.manualLayerMode;

        for (const brick of state.presetData) {
            state.selectedBrick = brick.type;
            state.selectedColor = window.colorData ? (window.colorData[brick.color] || '#CC0000') : '#CC0000';
            state.selectedColorName = brick.color;
            state.buildHeight = brick.z || 0;
            state.manualLayerMode = true;
            state.rotation = brick.rotation || 0;
            const prevCount = state.placedBricks.length;
            placeBrick(brick.x + offsetX, brick.y + offsetZ, brick.z);
            if (state.placedBricks.length > prevCount) placedCount++;
        }

        // Restore state ‚Äî keep preset mode active for repeat placement
        state.selectedBrick = savedBrick;
        state.selectedColor = savedColor;
        state.selectedColorName = savedColorName;
        state.buildHeight = savedHeight;
        state.rotation = savedRotation;
        state.manualLayerMode = savedManual;
        // Stay in preset mode so user can place again
        state.placementMode = 'preset';

        if (placedCount > 0) {
            showToast(`Placed ${state.presetName} (${placedCount} bricks) ‚Äî click again to place another, ESC to exit`, 'success');
        } else {
            showToast('Could not place ‚Äî area blocked', 'error');
        }
    }

    function switchToBrickModeFromPreset() {
        state.placementMode = 'brick';
        state.presetData = null;
        state.presetName = '';
        if (ghostPreset) { scene.remove(ghostPreset); ghostPreset = null; }
        if (ghostBrick) ghostBrick.visible = true;
        createGhostBrick();
        updateModeIndicator();
        updateCursorPosition();
    }

    async function loadSavedDesigns() {
        try {
            const res = await fetch('/api/designs');
            const data = await res.json();
            const container = document.getElementById('saved-designs');
            if(data.designs.length === 0) {
                container.innerHTML = '<div style="font-size:0.78em;color:var(--text2)">No saved designs yet</div>';
                return;
            }
            container.innerHTML = data.designs.map(d => `
                <div class="preset-item" onclick="loadSavedDesign('${d.id}')">
                    <div class="preset-name">${d.name}</div>
                    <div class="preset-desc">${d.brick_count} bricks ¬∑ ${d.mode}</div>
                </div>
            `).join('');
        } catch(e) {}
    }

    async function loadSavedDesign(id) {
        try {
            const res = await fetch(`/api/designs/${id}`);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            if(!data.design) return;

            clearSceneSilent();
            for(const brick of data.design.bricks) {
                state.selectedBrick = brick.type;
                state.selectedColor = window.colorData[brick.color] || '#CC0000';
                state.selectedColorName = brick.color;
                state.buildHeight = brick.z || 0;
                state.rotation = brick.rotation || 0;
                placeBrick(brick.x || 0, brick.y || 0);
            }
            state.selectedBrick = '2x4';
            state.selectedColor = '#CC0000';
            state.selectedColorName = 'red';
            state.buildHeight = 0;
            state.rotation = 0;
            createGhostBrick();
            document.getElementById('design-name').value = data.design.name;
            showToast(`Loaded: ${data.design.name}`, 'success');
        } catch(e) {
            console.error('Failed to load design:', e);
            showToast('Could not load design ‚Äî API unavailable', 'error');
        }
    }

    function clearSceneSilent() {
        while(bricksGroup.children.length > 0) bricksGroup.remove(bricksGroup.children[0]);
        state.placedBricks = [];
        state.history = [];
        state.selectedPlacedBrick = null;
    }

    // ========== SELECTION ==========
    function selectBrick(type) {
        state.selectedBrick = type;
        document.querySelectorAll('.brick-item').forEach(b => b.classList.remove('selected'));
        event.target.closest('.brick-item').classList.add('selected');
        // Switch back to brick mode when selecting a brick
        if (state.placementMode === 'minifig') {
            switchToBrickMode();
        } else {
            createGhostBrick();
        }
    }

    function selectColor(name, hex) {
        state.selectedColor = hex;
        state.selectedColorName = name;
        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
        event.target.classList.add('selected');
        createGhostBrick();
        // Update brick preview colors to show selected color
        document.querySelectorAll('.brick-preview').forEach(p => {
            p.style.background = hex;
        });
    }

    // ========== SAVE / EXPORT ==========
    async function saveDesign() {
        const name = document.getElementById('design-name').value || 'Untitled';
        const bricks = state.placedBricks.map(b => ({
            type: b.type,
            x: b.x,
            y: b.y,
            z: b.z,
            color: b.color,
            rotation: b.rotation || 0,
        }));

        try {
            const res = await fetch('/api/designs/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, bricks, mode: state.mode }),
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            showToast(`Design saved: ${name}`, 'success');
            loadSavedDesigns();
        } catch(e) {
            console.error('Failed to save design:', e);
            showToast('Could not save ‚Äî API unavailable. Try exporting as JSON instead.', 'error');
        }
    }

    async function exportSTL() {
        if(state.placedBricks.length === 0) {
            showToast('No bricks to export!', 'error');
            return;
        }

        const name = document.getElementById('design-name').value || 'design';
        const bricks = state.placedBricks.map(b => ({
            type: b.type,
            x: b.x,
            y: b.y,
            z: b.z,
            color: b.color,
        }));

        showToast('Exporting STL...');
        try {
            const res = await fetch('/api/export/stl', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, bricks }),
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();

            if (data.download_url) {
                const a = document.createElement('a');
                a.href = data.download_url;
                a.download = data.filename;
                a.click();
                showToast(`STL exported! ${data.vertices} vertices, ${data.faces} faces`, 'success');
            } else {
                showToast('Export failed: ' + (data.error || 'Unknown error'), 'error');
            }
        } catch(e) {
            console.error('STL export failed:', e);
            showToast('STL export unavailable ‚Äî API not connected', 'error');
        }
    }

    async function exportFor3MF() {
        if(state.placedBricks.length === 0) {
            showToast('No bricks to export!', 'error');
            return;
        }
        const name = document.getElementById('design-name').value || 'design';
        const bricks = state.placedBricks.map(b => ({
            type: b.type, x: b.x, y: b.y, z: b.z, color: b.color,
        }));
        showToast('Exporting 3MF for Bambu Studio...');
        try {
            const res = await fetch('/api/export/3mf', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, bricks }),
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            if(data.download_url) {
                const a = document.createElement('a');
                a.href = data.download_url;
                a.download = data.filename;
                a.click();
                showToast(`3MF exported! ${data.file_size_kb}KB ‚Äî Open in Bambu Studio!`, 'success');
            } else {
                showToast('Export failed: ' + (data.error || 'Unknown error'), 'error');
            }
        } catch(e) {
            console.error('3MF export failed:', e);
            showToast('3MF export unavailable ‚Äî API not connected', 'error');
        }
    }

    async function showBambuPanel() {
        const panel = document.getElementById('bambu-panel');
        panel.style.display = 'block';

        if(state.placedBricks.length === 0) {
            document.getElementById('bambu-info').innerHTML = '<span style="color:var(--warning)">Place some bricks first!</span>';
            return;
        }

        const bricks = state.placedBricks.map(b => ({
            type: b.type,
            x: b.x,
            y: b.y,
            z: b.z,
            color: b.color,
        }));

        try {
            const res = await fetch('/api/bambu/prepare', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bricks }),
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const s = data.bambu_settings;

            document.getElementById('bambu-info').innerHTML = `
                <strong>üìê Dimensions:</strong> ${s.dimensions.width_mm} √ó ${s.dimensions.depth_mm} √ó ${s.dimensions.height_mm} mm<br>
                <strong>üß± Bricks:</strong> ${s.brick_count}<br>
                <strong>‚è±Ô∏è Est. Time:</strong> ${s.estimated_time}<br>
                <strong>üì¶ Material:</strong> ${s.estimated_material}<br><br>
                <strong>üñ®Ô∏è Compatible Printers:</strong><br>
                ${Object.entries(s.fits_on_bed).map(([k,v]) => `&nbsp;&nbsp;${v ? '‚úÖ' : '‚ùå'} ${k}`).join('<br>')}<br><br>
                <strong>‚öôÔ∏è Settings:</strong><br>
                &nbsp;&nbsp;Layer: ${s.recommended_settings.layer_height}<br>
                &nbsp;&nbsp;Infill: ${s.recommended_settings.infill}<br>
                &nbsp;&nbsp;Material: ${s.recommended_settings.material}<br>
                &nbsp;&nbsp;Nozzle: ${s.recommended_settings.nozzle}<br>
                &nbsp;&nbsp;Walls: ${s.recommended_settings.wall_loops} loops<br><br>
                <strong>üìã Workflow:</strong><br>
                ${s.workflow.map(w => `&nbsp;&nbsp;${w}`).join('<br>')}
            `;
        } catch(e) {
            console.error('Bambu prepare failed:', e);
            document.getElementById('bambu-info').innerHTML = '<span style="color:var(--warning)">Bambu panel unavailable ‚Äî API not connected</span>';
        }
    }

    // ========== TOAST ==========
    function showToast(msg, type = '') {
        const existing = document.querySelector('.toast');
        if(existing) existing.remove();
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = msg;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
    }

    // ========== MIRROR MODE ==========
    let mirrorMode = false;
    let mirrorAxis = 'x';

    function toggleMirrorMode() {
        mirrorMode = !mirrorMode;
        document.getElementById('mirror-indicator').style.display = mirrorMode ? 'block' : 'none';
        document.getElementById('mirror-status').textContent = mirrorMode ? 'ON' : 'OFF';
        showToast(mirrorMode ? 'ü™û Mirror mode ON' : 'ü™û Mirror mode OFF', mirrorMode ? 'success' : '');
    }

    function setMirrorAxis(axis) {
        mirrorAxis = axis;
        document.getElementById('mirror-axis-display').textContent = axis.toUpperCase();
        showToast(`Mirror axis: ${axis.toUpperCase()}`);
    }

    // Override placeBrick to support mirror
    const _origPlaceBrick = placeBrick;
    placeBrick = function(gridX, gridZ) {
        _origPlaceBrick(gridX, gridZ);
        if (mirrorMode) {
            const center = 16; // Center of 32-stud baseplate
            let mirrorX = gridX, mirrorZ = gridZ;
            if (mirrorAxis === 'x') {
                mirrorX = 2 * center - gridX - (window.brickData[state.selectedBrick]?.depth || 4);
            } else {
                mirrorZ = 2 * center - gridZ - (window.brickData[state.selectedBrick]?.width || 2);
            }
            _origPlaceBrick(mirrorX, mirrorZ);
        }
    };

    // ========== COPY/DUPLICATE ==========
    function duplicateSelected() {
        if (!state.selectedPlacedBrick) {
            showToast('Select a brick first (Shift+Click)', 'error');
            return;
        }
        const brick = state.placedBricks.find(b => b.id === state.selectedPlacedBrick);
        if (!brick) return;

        state.selectedBrick = brick.type;
        state.selectedColor = brick.mesh.userData.color;
        state.selectedColorName = brick.color;
        state.buildHeight = brick.z + 1; // Place one layer above
        createGhostBrick();
        showToast(`Copied ${brick.type} ‚Äî click to place`, 'success');
    }

    // ========== SCREENSHOT ==========
    function takeScreenshot() {
        renderer.render(scene, camera);
        const dataURL = renderer.domElement.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataURL;
        a.download = `${document.getElementById('design-name').value || 'design'}_screenshot.png`;
        a.click();
        showToast('üì∏ Screenshot saved!', 'success');
    }

    // ========== BUILDING INSTRUCTIONS ==========
    async function showInstructions() {
        if (state.placedBricks.length === 0) {
            showToast('Place some bricks first!', 'error');
            return;
        }

        const bricks = state.placedBricks.map(b => ({
            type: b.type, x: b.x, y: b.y, z: b.z,
            color: b.color, rotation: b.rotation || 0,
        }));

        try {
            const res = await fetch('/api/instructions/generate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: document.getElementById('design-name').value, bricks }),
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const inst = data.instructions;

            let html = `
                <div class="modal-overlay" onclick="if(event.target===this)this.remove()">
                    <div class="modal">
                        <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">‚úï</button>
                        <h2>üìñ Building Instructions: ${inst.name}</h2>
                        <div style="display:flex;gap:16px;margin-bottom:16px;font-size:0.85em;">
                            <div>üß± <strong>${inst.total_bricks}</strong> bricks</div>
                            <div>üìã <strong>${inst.total_steps}</strong> steps</div>
                            <div>‚è±Ô∏è <strong>${inst.estimated_build_time}</strong></div>
                        </div>

                        <div class="tab-bar">
                            <button class="tab-btn active" onclick="showInstTab('steps',this)">üìã Steps</button>
                            <button class="tab-btn" onclick="showInstTab('parts',this)">üß± Parts List</button>
                        </div>

                        <div id="inst-steps">
            `;

            for (const step of inst.steps) {
                html += `
                    <div class="instruction-step">
                        <span class="step-num">${step.step}</span>
                        <span class="step-desc"><strong>${step.description}</strong></span>
                        <div class="step-bricks">
                            ${step.bricks.map(b => `${b.name} (${b.color}) at ${b.position}`).join(' ¬∑ ')}
                        </div>
                        <div style="font-size:0.7em;color:var(--text2);margin-top:4px;">
                            Total so far: ${step.cumulative_count} bricks
                        </div>
                    </div>
                `;
            }

            html += `</div><div id="inst-parts" style="display:none;">`;
            for (const part of inst.parts_list) {
                const hex = window.colorData?.[part.color] || '#888';
                html += `
                    <div class="parts-item">
                        <span class="parts-count">${part.count}√ó</span>
                        <div class="layer-color" style="background:${hex}"></div>
                        <span>${part.name}</span>
                        <span style="color:var(--text2);font-size:0.85em;margin-left:auto;">${part.color}</span>
                    </div>
                `;
            }
            html += `</div></div></div>`;

            document.body.insertAdjacentHTML('beforeend', html);
        } catch(e) {
            console.error('Instructions generation failed:', e);
            showToast('Instructions unavailable ‚Äî API not connected', 'error');
        }
    }

    function showInstTab(tab, btn) {
        document.getElementById('inst-steps').style.display = tab === 'steps' ? 'block' : 'none';
        document.getElementById('inst-parts').style.display = tab === 'parts' ? 'block' : 'none';
        btn.parentElement.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
    }

    // ========== MEASUREMENTS ==========
    async function showMeasurements() {
        if (state.placedBricks.length === 0) {
            showToast('Place some bricks first!', 'error');
            return;
        }

        const bricks = state.placedBricks.map(b => ({
            type: b.type, x: b.x, y: b.y, z: b.z, color: b.color,
        }));

        try {
            const res = await fetch('/api/tools/measure', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bricks }),
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const m = data.measurements;

            const html = `
                <div class="modal-overlay" onclick="if(event.target===this)this.remove()">
                    <div class="modal">
                        <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">‚úï</button>
                        <h2>üìè Design Measurements</h2>

                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:16px;">
                            <div style="background:var(--bg);padding:12px;border-radius:8px;text-align:center;">
                                <div style="font-size:1.5em;font-weight:700;color:var(--accent);">${m.bounding_box.width_mm}</div>
                                <div style="font-size:0.75em;color:var(--text2);">Width (mm)</div>
                            </div>
                            <div style="background:var(--bg);padding:12px;border-radius:8px;text-align:center;">
                                <div style="font-size:1.5em;font-weight:700;color:var(--success);">${m.bounding_box.depth_mm}</div>
                                <div style="font-size:0.75em;color:var(--text2);">Depth (mm)</div>
                            </div>
                            <div style="background:var(--bg);padding:12px;border-radius:8px;text-align:center;">
                                <div style="font-size:1.5em;font-weight:700;color:var(--warning);">${m.bounding_box.height_mm}</div>
                                <div style="font-size:0.75em;color:var(--text2);">Height (mm)</div>
                            </div>
                        </div>

                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:0.85em;">
                            <div>üß± <strong>Total Bricks:</strong> ${m.brick_count}</div>
                            <div>‚ö´ <strong>Total Studs:</strong> ${m.total_studs}</div>
                            <div>üé® <strong>Colors Used:</strong> ${m.unique_colors}</div>
                            <div>üì¶ <strong>Brick Types:</strong> ${m.unique_types}</div>
                            <div>‚öñÔ∏è <strong>Est. Weight:</strong> ${m.estimated_weight_g}g</div>
                            <div>üí∞ <strong>Est. Cost:</strong> $${m.estimated_cost_usd}</div>
                            <div>üìê <strong>Imperial:</strong> ${m.bounding_box.width_inches}" √ó ${m.bounding_box.depth_inches}" √ó ${m.bounding_box.height_inches}"</div>
                        </div>

                        <div style="margin-top:16px;">
                            <div class="panel-title">üé® Color Breakdown</div>
                            ${Object.entries(m.color_breakdown).map(([color, count]) =>
                                `<div class="parts-item">
                                    <div class="layer-color" style="background:${window.colorData?.[color] || '#888'}"></div>
                                    <span>${color}</span>
                                    <span class="parts-count" style="margin-left:auto;">${count}</span>
                                </div>`
                            ).join('')}
                        </div>

                        <div style="margin-top:16px;">
                            <div class="panel-title">üì¶ Brick Type Breakdown</div>
                            ${Object.entries(m.type_breakdown).map(([type, count]) =>
                                `<div class="parts-item">
                                    <span>${window.brickData?.[type]?.name || type}</span>
                                    <span class="parts-count" style="margin-left:auto;">${count}</span>
                                </div>`
                            ).join('')}
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', html);
        } catch(e) {
            console.error('Measurements failed:', e);
            showToast('Measurements unavailable ‚Äî API not connected', 'error');
        }
    }

    // ========== KEYBOARD SHORTCUTS HELP ==========
    function showHelp() {
        const html = `
            <div class="help-overlay" onclick="if(event.target===this)this.remove()">
                <div class="help-content">
                    <h2 style="margin-bottom:16px;">‚å®Ô∏è Keyboard Shortcuts</h2>
                    <div class="shortcut-row"><span>Place brick</span><span class="shortcut-key">Click</span></div>
                    <div class="shortcut-row"><span>Remove brick</span><span class="shortcut-key">Right Click</span></div>
                    <div class="shortcut-row"><span>Select brick</span><span class="shortcut-key">Shift + Click</span></div>
                    <div class="shortcut-row"><span>Rotate brick</span><span class="shortcut-key">R</span></div>
                    <div class="shortcut-row"><span>Layer up</span><span class="shortcut-key">E</span></div>
                    <div class="shortcut-row"><span>Layer down</span><span class="shortcut-key">Q</span></div>
                    <div class="shortcut-row"><span>Undo</span><span class="shortcut-key">Ctrl + Z</span></div>
                    <div class="shortcut-row"><span>Delete selected</span><span class="shortcut-key">Delete</span></div>
                    <div class="shortcut-row"><span>Toggle grid</span><span class="shortcut-key">G</span></div>
                    <div class="shortcut-row"><span>Toggle mirror</span><span class="shortcut-key">M</span></div>
                    <div class="shortcut-row"><span>Screenshot</span><span class="shortcut-key">P</span></div>
                    <div class="shortcut-row"><span>Save design</span><span class="shortcut-key">Ctrl + S</span></div>
                    <div class="shortcut-row"><span>Show help</span><span class="shortcut-key">?</span></div>
                    <div style="margin-top:16px;text-align:center;">
                        <button class="btn btn-primary" onclick="this.closest('.help-overlay').remove()">Got it! üëç</button>
                    </div>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', html);
    }

    // ========== TECHNIC PARTS LOADING ==========
    async function loadTechnicParts() {
        try {
            const res = await fetch('/api/technic');
            const data = await res.json();
            window.technicData = data.parts;

            const palette = document.getElementById('technic-palette');
            const icons = {
                beam: '‚ïê‚ïê‚ïê', axle: '‚îÄ‚îÄ', gear: '‚öôÔ∏è', pin: 'üìå',
                pin_axle: 'üìç', connector: 'üîó', wheel: '‚≠ï', tire: 'üîò',
                beam_L: '‚åê', beam_T: '‚î¨',
            };

            palette.innerHTML = Object.entries(data.parts).map(([key, info]) => `
                <div class="brick-item" onclick="selectTechnicPart('${key}')">
                    <span class="brick-icon">${icons[info.type] || '‚öôÔ∏è'}</span>
                    <span class="brick-name">${info.name}</span>
                </div>
            `).join('');
        } catch(e) { console.error('Failed to load technic parts:', e); }
    }

    function selectTechnicPart(partKey) {
        // For now, map to closest LEGO brick equivalent
        const technic = window.technicData[partKey];
        if (!technic) return;

        // Map technic parts to visual equivalents
        if (technic.type === 'beam') {
            const len = technic.length || 5;
            if (len <= 3) state.selectedBrick = '1x3';
            else if (len <= 4) state.selectedBrick = '1x4';
            else if (len <= 6) state.selectedBrick = '1x6';
            else state.selectedBrick = '1x8';
        } else if (technic.type === 'gear') {
            state.selectedBrick = technic.diameter <= 2 ? '1x1_round' : '2x2_round';
        } else if (technic.type === 'wheel' || technic.type === 'tire') {
            state.selectedBrick = technic.diameter <= 3 ? '1x1_round' : '2x2_round';
        } else {
            state.selectedBrick = '1x1';
        }
        createGhostBrick();
        showToast(`Selected: ${technic.name}`);
    }

    // ========== MINIFIGURE CHARACTER SYSTEM ==========
    const MINIFIG_CHARACTERS = [
        // === MARVEL (31) ===
        { id:'spiderman', name:'Spider-Man', cat:'marvel', head:'#FFD500', torso:'#CC0000', legs:'#0055BF', arms:'#CC0000', headgear:'#CC0000', headgearType:'mask', accent:'#000066', icon:'üï∑Ô∏è' },
        { id:'spiderman_black', name:'Black Spider', cat:'marvel', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#111111', headgear:'#111111', headgearType:'mask', accent:'#FFFFFF', icon:'üï∑Ô∏è' },
        { id:'spiderman_miles', name:'Miles Morales', cat:'marvel', head:'#8B5E3C', torso:'#111111', legs:'#111111', arms:'#111111', headgear:'#111111', headgearType:'mask', accent:'#CC0000', icon:'üï∑Ô∏è' },
        { id:'spiderman_2099', name:'Spider 2099', cat:'marvel', head:'#FFD500', torso:'#0055BF', legs:'#0055BF', arms:'#0055BF', headgear:'#0055BF', headgearType:'mask', accent:'#CC0000', icon:'üï∑Ô∏è' },
        { id:'spidergwen', name:'Spider-Gwen', cat:'marvel', head:'#FFD500', torso:'#FFFFFF', legs:'#111111', arms:'#FFFFFF', headgear:'#FFFFFF', headgearType:'mask', accent:'#FF69B4', icon:'üï∑Ô∏è' },
        { id:'ironman', name:'Iron Man', cat:'marvel', head:'#FFD500', torso:'#CC0000', legs:'#CC0000', arms:'#FFD500', headgear:'#CC0000', headgearType:'helmet', accent:'#FFD500', icon:'‚ö°' },
        { id:'ironman_gold', name:'Iron Man MK', cat:'marvel', head:'#FFD500', torso:'#8B0000', legs:'#8B0000', arms:'#FFD500', headgear:'#8B0000', headgearType:'helmet', accent:'#FFD500', icon:'‚ö°' },
        { id:'warmachine', name:'War Machine', cat:'marvel', head:'#FFD500', torso:'#444444', legs:'#444444', arms:'#666666', headgear:'#444444', headgearType:'helmet', accent:'#AAAAAA', icon:'üî´' },
        { id:'captain_america', name:'Cap America', cat:'marvel', head:'#FFD500', torso:'#0055BF', legs:'#8B0000', arms:'#FFD500', headgear:'#0055BF', headgearType:'helmet', accent:'#FFFFFF', icon:'üõ°Ô∏è' },
        { id:'thor', name:'Thor', cat:'marvel', head:'#FFD500', torso:'#555555', legs:'#0055BF', arms:'#FFD500', headgear:'#CCAA00', headgearType:'helmet', accent:'#CC0000', icon:'‚ö°' },
        { id:'hulk', name:'Hulk', cat:'marvel', head:'#2D8B46', torso:'#6B2FA0', legs:'#6B2FA0', arms:'#2D8B46', headgear:null, headgearType:null, accent:null, icon:'üí™' },
        { id:'blackwidow', name:'Black Widow', cat:'marvel', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#FFD500', headgear:'#8B2500', headgearType:'hair', accent:null, icon:'üï∂Ô∏è' },
        { id:'hawkeye', name:'Hawkeye', cat:'marvel', head:'#FFD500', torso:'#3B1F6E', legs:'#111111', arms:'#FFD500', headgear:null, headgearType:null, accent:'#3B1F6E', icon:'üèπ' },
        { id:'blackpanther', name:'Black Panther', cat:'marvel', head:'#111111', torso:'#111111', legs:'#111111', arms:'#111111', headgear:'#111111', headgearType:'mask', accent:'#C0C0C0', icon:'üêæ' },
        { id:'drstrange', name:'Dr. Strange', cat:'marvel', head:'#FFD500', torso:'#0055BF', legs:'#0055BF', arms:'#CC0000', headgear:null, headgearType:null, accent:'#CC0000', icon:'‚ú®' },
        { id:'scarletwitch', name:'Scarlet Witch', cat:'marvel', head:'#FFD500', torso:'#CC0000', legs:'#CC0000', arms:'#CC0000', headgear:'#CC0000', headgearType:'crown', accent:'#FF3366', icon:'üîÆ' },
        { id:'vision', name:'Vision', cat:'marvel', head:'#CC0000', torso:'#228B22', legs:'#228B22', arms:'#CC0000', headgear:'#FFD500', headgearType:'gem', accent:'#FFD500', icon:'üíé' },
        { id:'antman', name:'Ant-Man', cat:'marvel', head:'#FFD500', torso:'#CC0000', legs:'#111111', arms:'#FFD500', headgear:'#CC0000', headgearType:'helmet', accent:'#C0C0C0', icon:'üêú' },
        { id:'wasp', name:'Wasp', cat:'marvel', head:'#FFD500', torso:'#FFD500', legs:'#111111', arms:'#FFD500', headgear:'#FFD500', headgearType:'helmet', accent:'#111111', icon:'üêù' },
        { id:'groot', name:'Groot', cat:'marvel', head:'#8B5E3C', torso:'#8B5E3C', legs:'#8B5E3C', arms:'#8B5E3C', headgear:null, headgearType:null, accent:'#228B22', icon:'üå±' },
        { id:'rocket', name:'Rocket', cat:'marvel', head:'#8B5E3C', torso:'#FF6600', legs:'#333333', arms:'#8B5E3C', headgear:null, headgearType:null, accent:null, icon:'ü¶ù' },
        { id:'starlord', name:'Star-Lord', cat:'marvel', head:'#FFD500', torso:'#CC0000', legs:'#111111', arms:'#CC0000', headgear:'#CC0000', headgearType:'helmet', accent:'#C0C0C0', icon:'üåü' },
        { id:'gamora', name:'Gamora', cat:'marvel', head:'#228B22', torso:'#111111', legs:'#111111', arms:'#228B22', headgear:'#111111', headgearType:'hair', accent:null, icon:'‚öîÔ∏è' },
        { id:'thanos', name:'Thanos', cat:'marvel', head:'#6B2FA0', torso:'#0055BF', legs:'#0055BF', arms:'#6B2FA0', headgear:'#FFD500', headgearType:'helmet', accent:'#FFD500', icon:'üß§' },
        { id:'loki', name:'Loki', cat:'marvel', head:'#FFD500', torso:'#006400', legs:'#006400', arms:'#FFD500', headgear:'#FFD500', headgearType:'crown', accent:'#006400', icon:'üêç' },
        { id:'venom', name:'Venom', cat:'marvel', head:'#111111', torso:'#111111', legs:'#111111', arms:'#111111', headgear:null, headgearType:null, accent:'#FFFFFF', icon:'üëÖ' },
        { id:'carnage', name:'Carnage', cat:'marvel', head:'#CC0000', torso:'#CC0000', legs:'#CC0000', arms:'#CC0000', headgear:null, headgearType:null, accent:'#111111', icon:'ü©∏' },
        { id:'deadpool', name:'Deadpool', cat:'marvel', head:'#CC0000', torso:'#CC0000', legs:'#CC0000', arms:'#CC0000', headgear:'#CC0000', headgearType:'mask', accent:'#111111', icon:'üíÄ' },
        { id:'wolverine', name:'Wolverine', cat:'marvel', head:'#FFD500', torso:'#FFD500', legs:'#0055BF', arms:'#FFD500', headgear:'#111111', headgearType:'mask', accent:'#FFD500', icon:'üê∫' },
        { id:'storm', name:'Storm', cat:'marvel', head:'#8B5E3C', torso:'#FFFFFF', legs:'#111111', arms:'#8B5E3C', headgear:'#FFFFFF', headgearType:'hair', accent:null, icon:'‚õàÔ∏è' },
        { id:'magneto', name:'Magneto', cat:'marvel', head:'#FFD500', torso:'#CC0000', legs:'#6B2FA0', arms:'#FFD500', headgear:'#CC0000', headgearType:'helmet', accent:'#6B2FA0', icon:'üß≤' },
        { id:'cyclops', name:'Cyclops', cat:'marvel', head:'#FFD500', torso:'#0055BF', legs:'#0055BF', arms:'#FFD500', headgear:'#CC0000', headgearType:'visor', accent:'#FFD500', icon:'üëÅÔ∏è' },
        { id:'shehulk', name:'She-Hulk', cat:'marvel', head:'#2D8B46', torso:'#FFFFFF', legs:'#6B2FA0', arms:'#2D8B46', headgear:'#111111', headgearType:'hair', accent:null, icon:'üí™' },
        { id:'moonknight', name:'Moon Knight', cat:'marvel', head:'#FFFFFF', torso:'#FFFFFF', legs:'#FFFFFF', arms:'#FFFFFF', headgear:'#FFFFFF', headgearType:'mask', accent:'#C0C0C0', icon:'üåô' },
        { id:'msmarvel', name:'Ms. Marvel', cat:'marvel', head:'#8B5E3C', torso:'#0055BF', legs:'#CC0000', arms:'#8B5E3C', headgear:'#111111', headgearType:'hair', accent:'#FFD500', icon:'‚≠ê' },
        // === DC (15) ===
        { id:'batman', name:'Batman', cat:'dc', head:'#FFD500', torso:'#333333', legs:'#333333', arms:'#333333', headgear:'#111111', headgearType:'mask', accent:'#FFD500', icon:'ü¶á' },
        { id:'batman_dark', name:'Dark Knight', cat:'dc', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#111111', headgear:'#111111', headgearType:'mask', accent:'#333333', icon:'ü¶á' },
        { id:'superman', name:'Superman', cat:'dc', head:'#FFD500', torso:'#0055BF', legs:'#CC0000', arms:'#FFD500', headgear:'#111111', headgearType:'hair', accent:'#CC0000', icon:'ü¶∏' },
        { id:'wonderwoman', name:'Wonder Woman', cat:'dc', head:'#FFD500', torso:'#CC0000', legs:'#0055BF', arms:'#FFD500', headgear:'#FFD500', headgearType:'crown', accent:'#FFD500', icon:'‚≠ê' },
        { id:'flash', name:'Flash', cat:'dc', head:'#FFD500', torso:'#CC0000', legs:'#CC0000', arms:'#CC0000', headgear:'#CC0000', headgearType:'mask', accent:'#FFD500', icon:'‚ö°' },
        { id:'aquaman', name:'Aquaman', cat:'dc', head:'#FFD500', torso:'#FF8C00', legs:'#006400', arms:'#FFD500', headgear:'#FFD500', headgearType:'hair', accent:'#006400', icon:'üî±' },
        { id:'greenlantern', name:'Green Lantern', cat:'dc', head:'#FFD500', torso:'#228B22', legs:'#111111', arms:'#228B22', headgear:'#228B22', headgearType:'mask', accent:'#228B22', icon:'üíç' },
        { id:'robin', name:'Robin', cat:'dc', head:'#FFD500', torso:'#CC0000', legs:'#006400', arms:'#FFD500', headgear:'#111111', headgearType:'mask', accent:'#FFD500', icon:'üê¶' },
        { id:'batgirl', name:'Batgirl', cat:'dc', head:'#FFD500', torso:'#6B2FA0', legs:'#6B2FA0', arms:'#FFD500', headgear:'#6B2FA0', headgearType:'mask', accent:'#FFD500', icon:'ü¶á' },
        { id:'joker', name:'Joker', cat:'dc', head:'#FFFFFF', torso:'#6B2FA0', legs:'#6B2FA0', arms:'#FFFFFF', headgear:'#228B22', headgearType:'hair', accent:'#CC0000', icon:'üÉè' },
        { id:'harleyquinn', name:'Harley Quinn', cat:'dc', head:'#FFFFFF', torso:'#CC0000', legs:'#111111', arms:'#FFFFFF', headgear:'#CC0000', headgearType:'hair', accent:'#0055BF', icon:'üíé' },
        { id:'catwoman', name:'Catwoman', cat:'dc', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#111111', headgear:'#111111', headgearType:'mask', accent:null, icon:'üê±' },
        { id:'penguin', name:'Penguin', cat:'dc', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#FFD500', headgear:'#111111', headgearType:'hat', accent:'#FFFFFF', icon:'üêß' },
        { id:'poison_ivy', name:'Poison Ivy', cat:'dc', head:'#228B22', torso:'#228B22', legs:'#228B22', arms:'#228B22', headgear:'#CC0000', headgearType:'hair', accent:'#CC0000', icon:'üåø' },
        { id:'cyborg', name:'Cyborg', cat:'dc', head:'#8B5E3C', torso:'#C0C0C0', legs:'#C0C0C0', arms:'#C0C0C0', headgear:null, headgearType:null, accent:'#CC0000', icon:'ü§ñ' },
        // === STAR WARS (16) ===
        { id:'luke', name:'Luke Skywalker', cat:'starwars', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#FFD500', headgear:'#8B5E3C', headgearType:'hair', accent:null, icon:'‚öîÔ∏è' },
        { id:'darthvader', name:'Darth Vader', cat:'starwars', head:'#111111', torso:'#111111', legs:'#111111', arms:'#111111', headgear:'#111111', headgearType:'helmet', accent:'#CC0000', icon:'‚ö´' },
        { id:'yoda', name:'Yoda', cat:'starwars', head:'#228B22', torso:'#8B5E3C', legs:'#8B5E3C', arms:'#228B22', headgear:null, headgearType:null, accent:'#228B22', icon:'üëΩ' },
        { id:'stormtrooper', name:'Stormtrooper', cat:'starwars', head:'#FFFFFF', torso:'#FFFFFF', legs:'#FFFFFF', arms:'#FFFFFF', headgear:'#FFFFFF', headgearType:'helmet', accent:'#111111', icon:'‚ö™' },
        { id:'bobafett', name:'Boba Fett', cat:'starwars', head:'#FFD500', torso:'#228B22', legs:'#228B22', arms:'#228B22', headgear:'#228B22', headgearType:'helmet', accent:'#CC0000', icon:'üöÄ' },
        { id:'mandalorian', name:'Mandalorian', cat:'starwars', head:'#FFD500', torso:'#C0C0C0', legs:'#C0C0C0', arms:'#C0C0C0', headgear:'#C0C0C0', headgearType:'helmet', accent:'#0055BF', icon:'üõ°Ô∏è' },
        { id:'chewbacca', name:'Chewbacca', cat:'starwars', head:'#8B5E3C', torso:'#8B5E3C', legs:'#8B5E3C', arms:'#8B5E3C', headgear:null, headgearType:null, accent:'#A0522D', icon:'üêª' },
        { id:'hansolo', name:'Han Solo', cat:'starwars', head:'#FFD500', torso:'#FFFFFF', legs:'#0055BF', arms:'#FFD500', headgear:'#8B5E3C', headgearType:'hair', accent:null, icon:'üî´' },
        { id:'leia', name:'Princess Leia', cat:'starwars', head:'#FFD500', torso:'#FFFFFF', legs:'#FFFFFF', arms:'#FFD500', headgear:'#8B5E3C', headgearType:'hair', accent:null, icon:'üë∏' },
        { id:'obiwan', name:'Obi-Wan', cat:'starwars', head:'#FFD500', torso:'#A0522D', legs:'#A0522D', arms:'#FFD500', headgear:'#8B5E3C', headgearType:'hair', accent:null, icon:'‚öîÔ∏è' },
        { id:'kylo_ren', name:'Kylo Ren', cat:'starwars', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#111111', headgear:'#111111', headgearType:'helmet', accent:'#CC0000', icon:'‚öîÔ∏è' },
        { id:'rey', name:'Rey', cat:'starwars', head:'#FFD500', torso:'#D2B48C', legs:'#D2B48C', arms:'#FFD500', headgear:'#8B5E3C', headgearType:'hair', accent:null, icon:'‚≠ê' },
        { id:'macewindu', name:'Mace Windu', cat:'starwars', head:'#8B5E3C', torso:'#6B2FA0', legs:'#A0522D', arms:'#8B5E3C', headgear:null, headgearType:null, accent:'#6B2FA0', icon:'‚öîÔ∏è' },
        { id:'darthmaul', name:'Darth Maul', cat:'starwars', head:'#CC0000', torso:'#111111', legs:'#111111', arms:'#CC0000', headgear:'#CC0000', headgearType:'horns', accent:'#111111', icon:'üòà' },
        { id:'r2d2', name:'R2-D2', cat:'starwars', head:'#FFFFFF', torso:'#0055BF', legs:'#FFFFFF', arms:'#FFFFFF', headgear:'#0055BF', headgearType:'dome', accent:'#C0C0C0', icon:'ü§ñ' },
        { id:'c3po', name:'C-3PO', cat:'starwars', head:'#FFD500', torso:'#FFD500', legs:'#FFD500', arms:'#FFD500', headgear:null, headgearType:null, accent:'#CC8800', icon:'ü§ñ' },
        // === MINECRAFT (22) ===
        { id:'mc_steve', name:'Steve', cat:'minecraft', head:'#8B5E3C', torso:'#00AADD', legs:'#3333AA', arms:'#8B5E3C', headgear:'#553311', headgearType:'hair', accent:null, icon:'‚õèÔ∏è' },
        { id:'mc_alex', name:'Alex', cat:'minecraft', head:'#FFD500', torso:'#44AA44', legs:'#554433', arms:'#FFD500', headgear:'#CC5500', headgearType:'hair', accent:null, icon:'‚õèÔ∏è' },
        { id:'mc_creeper', name:'Creeper', cat:'minecraft', head:'#55CC55', torso:'#55CC55', legs:'#55CC55', arms:'#55CC55', headgear:null, headgearType:null, accent:'#111111', icon:'üí•' },
        { id:'mc_zombie', name:'MC Zombie', cat:'minecraft', head:'#558855', torso:'#00AADD', legs:'#3333AA', arms:'#558855', headgear:null, headgearType:null, accent:'#111111', icon:'üßü' },
        { id:'mc_skeleton', name:'MC Skeleton', cat:'minecraft', head:'#DDDDDD', torso:'#CCCCCC', legs:'#CCCCCC', arms:'#DDDDDD', headgear:null, headgearType:null, accent:'#333333', icon:'üíÄ' },
        { id:'mc_enderman', name:'Enderman', cat:'minecraft', head:'#111111', torso:'#111111', legs:'#111111', arms:'#111111', headgear:null, headgearType:null, accent:'#CC00FF', icon:'üëæ' },
        { id:'mc_blaze', name:'Blaze', cat:'minecraft', head:'#FFAA00', torso:'#FF8800', legs:'#FF6600', arms:'#FFAA00', headgear:null, headgearType:null, accent:'#FFDD00', icon:'üî•' },
        { id:'mc_ghast', name:'Ghast', cat:'minecraft', head:'#EEEEEE', torso:'#EEEEEE', legs:'#DDDDDD', arms:'#EEEEEE', headgear:null, headgearType:null, accent:'#CC0000', icon:'üëª' },
        { id:'mc_wither', name:'Wither', cat:'minecraft', head:'#333333', torso:'#222222', legs:'#222222', arms:'#333333', headgear:null, headgearType:null, accent:'#555555', icon:'‚ò†Ô∏è' },
        { id:'mc_dragon', name:'Ender Dragon', cat:'minecraft', head:'#1A1A2E', torso:'#1A1A2E', legs:'#1A1A2E', arms:'#1A1A2E', headgear:'#1A1A2E', headgearType:'horns', accent:'#CC00FF', icon:'üêâ' },
        { id:'mc_iron_golem', name:'Iron Golem', cat:'minecraft', head:'#CCCCCC', torso:'#BBBBBB', legs:'#AAAAAA', arms:'#CCCCCC', headgear:null, headgearType:null, accent:'#228B22', icon:'ü§ñ' },
        { id:'mc_villager', name:'Villager', cat:'minecraft', head:'#C49A6C', torso:'#8B5E3C', legs:'#8B5E3C', arms:'#C49A6C', headgear:'#8B5E3C', headgearType:'hat', accent:'#228B22', icon:'üë®‚Äçüåæ' },
        { id:'mc_witch', name:'Witch', cat:'minecraft', head:'#C49A6C', torso:'#6B2FA0', legs:'#6B2FA0', arms:'#C49A6C', headgear:'#111111', headgearType:'hat', accent:'#228B22', icon:'üßô‚Äç‚ôÄÔ∏è' },
        { id:'mc_pillager', name:'Pillager', cat:'minecraft', head:'#999999', torso:'#444444', legs:'#333333', arms:'#999999', headgear:'#444444', headgearType:'mask', accent:'#CC0000', icon:'üèπ' },
        { id:'mc_warden', name:'Warden', cat:'minecraft', head:'#0A4444', torso:'#0A3333', legs:'#0A2222', arms:'#0A4444', headgear:null, headgearType:null, accent:'#00DDDD', icon:'üëπ' },
        { id:'mc_piglin', name:'Piglin', cat:'minecraft', head:'#CC8866', torso:'#111111', legs:'#111111', arms:'#CC8866', headgear:'#FFD500', headgearType:'crown', accent:'#FFD500', icon:'üê∑' },
        { id:'mc_herobrine', name:'Herobrine', cat:'minecraft', head:'#8B5E3C', torso:'#00AADD', legs:'#3333AA', arms:'#8B5E3C', headgear:'#553311', headgearType:'hair', accent:'#FFFFFF', icon:'üëÅÔ∏è' },
        { id:'mc_wolf', name:'Wolf/Dog', cat:'minecraft', head:'#CCCCCC', torso:'#DDDDDD', legs:'#CCCCCC', arms:'#CCCCCC', headgear:null, headgearType:null, accent:'#CC0000', icon:'üê∫' },
        { id:'mc_cat', name:'Cat/Ocelot', cat:'minecraft', head:'#FFCC66', torso:'#FFCC66', legs:'#FFCC66', arms:'#FFCC66', headgear:null, headgearType:null, accent:'#333333', icon:'üê±' },
        { id:'mc_bee', name:'Bee', cat:'minecraft', head:'#FFDD00', torso:'#111111', legs:'#FFDD00', arms:'#FFDD00', headgear:null, headgearType:null, accent:'#111111', icon:'üêù' },
        { id:'mc_axolotl', name:'Axolotl', cat:'minecraft', head:'#FF88AA', torso:'#FF88AA', legs:'#FF88AA', arms:'#FF88AA', headgear:null, headgearType:null, accent:'#FF4477', icon:'ü¶é' },
        { id:'mc_allay', name:'Allay', cat:'minecraft', head:'#88CCFF', torso:'#88CCFF', legs:'#6699FF', arms:'#88CCFF', headgear:null, headgearType:null, accent:'#FFFFFF', icon:'üßö' },
        // --- Minecraft Animals & Passive Mobs ---
        { id:'mc_pig', name:'Pig', cat:'minecraft', head:'#FFAAAA', torso:'#FFAAAA', legs:'#FFAAAA', arms:'#FFAAAA', headgear:null, headgearType:null, accent:'#FF7777', icon:'üê∑' },
        { id:'mc_cow', name:'Cow', cat:'minecraft', head:'#6B4226', torso:'#FFFFFF', legs:'#6B4226', arms:'#6B4226', headgear:null, headgearType:null, accent:'#FFFFFF', icon:'üêÑ' },
        { id:'mc_mooshroom', name:'Mooshroom', cat:'minecraft', head:'#CC3333', torso:'#CCCCCC', legs:'#CC3333', arms:'#CC3333', headgear:null, headgearType:null, accent:'#FF4444', icon:'üçÑ' },
        { id:'mc_sheep', name:'Sheep', cat:'minecraft', head:'#EEEEEE', torso:'#DDDDDD', legs:'#888888', arms:'#EEEEEE', headgear:null, headgearType:null, accent:'#FFFFFF', icon:'üêë' },
        { id:'mc_chicken', name:'Chicken', cat:'minecraft', head:'#FFFFFF', torso:'#FFFFFF', legs:'#FFAA00', arms:'#FFFFFF', headgear:null, headgearType:null, accent:'#FF3333', icon:'üêî' },
        { id:'mc_horse', name:'Horse', cat:'minecraft', head:'#8B6914', torso:'#8B6914', legs:'#7A5C12', arms:'#8B6914', headgear:null, headgearType:null, accent:'#5C3D0E', icon:'üê¥' },
        { id:'mc_donkey', name:'Donkey', cat:'minecraft', head:'#7A6952', torso:'#7A6952', legs:'#6B5B45', arms:'#7A6952', headgear:null, headgearType:null, accent:'#5C4D3A', icon:'ü´è' },
        { id:'mc_llama', name:'Llama', cat:'minecraft', head:'#E8D5B7', torso:'#C4A882', legs:'#C4A882', arms:'#E8D5B7', headgear:null, headgearType:null, accent:'#8B6914', icon:'ü¶ô' },
        { id:'mc_rabbit', name:'Rabbit', cat:'minecraft', head:'#C4A060', torso:'#C4A060', legs:'#C4A060', arms:'#C4A060', headgear:null, headgearType:null, accent:'#FFFFFF', icon:'üêá' },
        { id:'mc_fox', name:'Fox', cat:'minecraft', head:'#FF8833', torso:'#FFFFFF', legs:'#333333', arms:'#FF8833', headgear:null, headgearType:null, accent:'#FFFFFF', icon:'ü¶ä' },
        { id:'mc_panda', name:'Panda', cat:'minecraft', head:'#FFFFFF', torso:'#FFFFFF', legs:'#333333', arms:'#333333', headgear:null, headgearType:null, accent:'#333333', icon:'üêº' },
        { id:'mc_polar_bear', name:'Polar Bear', cat:'minecraft', head:'#F0F0F0', torso:'#E8E8E8', legs:'#E0E0E0', arms:'#F0F0F0', headgear:null, headgearType:null, accent:'#CCCCCC', icon:'üêª‚Äç‚ùÑÔ∏è' },
        { id:'mc_turtle', name:'Sea Turtle', cat:'minecraft', head:'#228B22', torso:'#2E8B22', legs:'#228B22', arms:'#228B22', headgear:'#2E8B57', headgearType:'helmet', accent:'#00AA00', icon:'üê¢' },
        { id:'mc_dolphin', name:'Dolphin', cat:'minecraft', head:'#6688AA', torso:'#AABBCC', legs:'#6688AA', arms:'#6688AA', headgear:null, headgearType:null, accent:'#AABBCC', icon:'üê¨' },
        { id:'mc_squid', name:'Squid', cat:'minecraft', head:'#334466', torso:'#334466', legs:'#223355', arms:'#334466', headgear:null, headgearType:null, accent:'#4466AA', icon:'ü¶ë' },
        { id:'mc_glow_squid', name:'Glow Squid', cat:'minecraft', head:'#00AAAA', torso:'#008888', legs:'#006666', arms:'#00AAAA', headgear:null, headgearType:null, accent:'#00FFFF', icon:'‚ú®' },
        { id:'mc_frog', name:'Frog', cat:'minecraft', head:'#77AA44', torso:'#77AA44', legs:'#77AA44', arms:'#77AA44', headgear:null, headgearType:null, accent:'#FF6633', icon:'üê∏' },
        { id:'mc_parrot', name:'Parrot', cat:'minecraft', head:'#FF3333', torso:'#0088FF', legs:'#888888', arms:'#FFDD00', headgear:null, headgearType:null, accent:'#00FF00', icon:'ü¶ú' },
        { id:'mc_strider', name:'Strider', cat:'minecraft', head:'#883333', torso:'#883333', legs:'#444444', arms:'#883333', headgear:null, headgearType:null, accent:'#666666', icon:'üåã' },
        { id:'mc_sniffer', name:'Sniffer', cat:'minecraft', head:'#AA6633', torso:'#886622', legs:'#885522', arms:'#AA6633', headgear:null, headgearType:null, accent:'#44AA44', icon:'üå±' },
        { id:'mc_camel', name:'Camel', cat:'minecraft', head:'#D4A04A', torso:'#C49040', legs:'#B48030', arms:'#D4A04A', headgear:null, headgearType:null, accent:'#8B6914', icon:'üê´' },
        { id:'mc_armadillo', name:'Armadillo', cat:'minecraft', head:'#AA7744', torso:'#997733', legs:'#886622', arms:'#AA7744', headgear:'#997733', headgearType:'helmet', accent:'#775522', icon:'ü¶î' },
        // --- Minecraft Hostile Mobs ---
        { id:'mc_spider', name:'MC Spider', cat:'minecraft', head:'#333333', torso:'#333333', legs:'#333333', arms:'#333333', headgear:null, headgearType:null, accent:'#FF0000', icon:'üï∑Ô∏è' },
        { id:'mc_cave_spider', name:'Cave Spider', cat:'minecraft', head:'#004466', torso:'#003355', legs:'#003355', arms:'#004466', headgear:null, headgearType:null, accent:'#FF0000', icon:'üï∏Ô∏è' },
        { id:'mc_slime', name:'Slime', cat:'minecraft', head:'#66CC44', torso:'#66CC44', legs:'#66CC44', arms:'#66CC44', headgear:null, headgearType:null, accent:'#44AA22', icon:'üü¢' },
        { id:'mc_magma_cube', name:'Magma Cube', cat:'minecraft', head:'#CC3300', torso:'#AA2200', legs:'#CC3300', arms:'#CC3300', headgear:null, headgearType:null, accent:'#FF6600', icon:'üî•' },
        { id:'mc_phantom', name:'Phantom', cat:'minecraft', head:'#2244AA', torso:'#334488', legs:'#2244AA', arms:'#557799', headgear:null, headgearType:null, accent:'#44FF44', icon:'üëª' },
        { id:'mc_drowned', name:'Drowned', cat:'minecraft', head:'#336655', torso:'#336655', legs:'#225544', arms:'#336655', headgear:null, headgearType:null, accent:'#00AAAA', icon:'üßü' },
        { id:'mc_husk', name:'Husk', cat:'minecraft', head:'#B8A080', torso:'#998866', legs:'#887755', arms:'#B8A080', headgear:null, headgearType:null, accent:'#776644', icon:'üèúÔ∏è' },
        { id:'mc_stray', name:'Stray', cat:'minecraft', head:'#AABBCC', torso:'#88AACC', legs:'#778899', arms:'#AABBCC', headgear:'#778899', headgearType:'hat', accent:'#6688AA', icon:'‚ùÑÔ∏è' },
        { id:'mc_guardian', name:'Guardian', cat:'minecraft', head:'#669988', torso:'#558877', legs:'#669988', arms:'#77AA99', headgear:null, headgearType:null, accent:'#FF6600', icon:'üê°' },
        { id:'mc_elder_guardian', name:'Elder Guardian', cat:'minecraft', head:'#BBAA88', torso:'#AA9977', legs:'#BBAA88', arms:'#CCBB99', headgear:null, headgearType:null, accent:'#CC00CC', icon:'üëÅÔ∏è' },
        { id:'mc_shulker', name:'Shulker', cat:'minecraft', head:'#9966CC', torso:'#8855BB', legs:'#9966CC', arms:'#9966CC', headgear:'#9966CC', headgearType:'helmet', accent:'#FFFFFF', icon:'üì¶' },
        { id:'mc_vex', name:'Vex', cat:'minecraft', head:'#AACCEE', torso:'#8899BB', legs:'#AACCEE', arms:'#AACCEE', headgear:null, headgearType:null, accent:'#FF4444', icon:'üó°Ô∏è' },
        { id:'mc_evoker', name:'Evoker', cat:'minecraft', head:'#BBBBBB', torso:'#555555', legs:'#444444', arms:'#BBBBBB', headgear:null, headgearType:null, accent:'#FFD500', icon:'üßô' },
        { id:'mc_vindicator', name:'Vindicator', cat:'minecraft', head:'#BBBBBB', torso:'#555555', legs:'#444444', arms:'#BBBBBB', headgear:null, headgearType:null, accent:'#228B22', icon:'ü™ì' },
        { id:'mc_ravager', name:'Ravager', cat:'minecraft', head:'#555555', torso:'#444444', legs:'#333333', arms:'#555555', headgear:'#666666', headgearType:'helmet', accent:'#333333', icon:'üêÉ' },
        { id:'mc_hoglin', name:'Hoglin', cat:'minecraft', head:'#886655', torso:'#775544', legs:'#664433', arms:'#886655', headgear:'#886655', headgearType:'horns', accent:'#554433', icon:'üêó' },
        { id:'mc_zoglin', name:'Zoglin', cat:'minecraft', head:'#CC7788', torso:'#BB6677', legs:'#AA5566', arms:'#CC7788', headgear:'#CC7788', headgearType:'horns', accent:'#44FF44', icon:'üßü' },
        { id:'mc_piglin_brute', name:'Piglin Brute', cat:'minecraft', head:'#DDBB88', torso:'#111111', legs:'#8B6914', arms:'#DDBB88', headgear:'#FFD500', headgearType:'crown', accent:'#FFD500', icon:'‚öîÔ∏è' },
        { id:'mc_wither_skeleton', name:'Wither Skeleton', cat:'minecraft', head:'#333333', torso:'#222222', legs:'#222222', arms:'#333333', headgear:null, headgearType:null, accent:'#111111', icon:'üíÄ' },
        { id:'mc_silverfish', name:'Silverfish', cat:'minecraft', head:'#999999', torso:'#888888', legs:'#777777', arms:'#999999', headgear:null, headgearType:null, accent:'#AAAAAA', icon:'üêõ' },
        { id:'mc_endermite', name:'Endermite', cat:'minecraft', head:'#7744AA', torso:'#6633AA', legs:'#5522AA', arms:'#7744AA', headgear:null, headgearType:null, accent:'#9966CC', icon:'ü™≤' },
        { id:'mc_breeze', name:'Breeze', cat:'minecraft', head:'#88CCFF', torso:'#66AADD', legs:'#4488BB', arms:'#88CCFF', headgear:null, headgearType:null, accent:'#AAEEFF', icon:'üí®' },
        { id:'mc_bogged', name:'Bogged', cat:'minecraft', head:'#556644', torso:'#445533', legs:'#334422', arms:'#556644', headgear:null, headgearType:null, accent:'#88AA66', icon:'ü™¥' },
        // --- Minecraft NPCs & Neutral ---
        { id:'mc_wandering_trader', name:'Wandering Trader', cat:'minecraft', head:'#BBBBBB', torso:'#0055AA', legs:'#0055AA', arms:'#BBBBBB', headgear:'#0055AA', headgearType:'hat', accent:'#FFD500', icon:'üß≥' },
        { id:'mc_nitwit', name:'Nitwit Villager', cat:'minecraft', head:'#BBBBBB', torso:'#228B22', legs:'#228B22', arms:'#BBBBBB', headgear:'#228B22', headgearType:'hat', accent:'#228B22', icon:'üü¢' },
        { id:'mc_cleric', name:'Cleric Villager', cat:'minecraft', head:'#BBBBBB', torso:'#9933CC', legs:'#9933CC', arms:'#BBBBBB', headgear:'#9933CC', headgearType:'hat', accent:'#FFD500', icon:'‚öóÔ∏è' },
        { id:'mc_librarian', name:'Librarian Villager', cat:'minecraft', head:'#BBBBBB', torso:'#FFFFFF', legs:'#FFFFFF', arms:'#BBBBBB', headgear:'#FFFFFF', headgearType:'hat', accent:'#886644', icon:'üìö' },
        { id:'mc_blacksmith', name:'Blacksmith Villager', cat:'minecraft', head:'#BBBBBB', torso:'#333333', legs:'#333333', arms:'#BBBBBB', headgear:'#333333', headgearType:'hat', accent:'#FF8800', icon:'‚öíÔ∏è' },
        { id:'mc_snow_golem', name:'Snow Golem', cat:'minecraft', head:'#FFFFFF', torso:'#F0F0F0', legs:'#E8E8E8', arms:'#FFFFFF', headgear:'#FF8800', headgearType:'hat', accent:'#FF6600', icon:'‚õÑ' },
        { id:'mc_zombie_villager', name:'Zombie Villager', cat:'minecraft', head:'#668844', torso:'#886644', legs:'#775533', arms:'#668844', headgear:'#886644', headgearType:'hat', accent:'#44AA22', icon:'üßü' },
        // --- Minecraft Story Mode Characters ---
        { id:'mc_jesse_m', name:'Jesse (Male)', cat:'minecraft', head:'#DDBB88', torso:'#FFFFFF', legs:'#0055BF', arms:'#DDBB88', headgear:'#4A3728', headgearType:'hair', accent:'#228B22', icon:'‚öîÔ∏è' },
        { id:'mc_jesse_f', name:'Jesse (Female)', cat:'minecraft', head:'#DDBB88', torso:'#FFFFFF', legs:'#0055BF', arms:'#DDBB88', headgear:'#8B2500', headgearType:'hair', accent:'#CC3333', icon:'‚öîÔ∏è' },
        { id:'mc_petra', name:'Petra', cat:'minecraft', head:'#DDBB88', torso:'#AA4422', legs:'#333333', arms:'#DDBB88', headgear:'#CC4400', headgearType:'hair', accent:'#FFD500', icon:'üó°Ô∏è' },
        { id:'mc_olivia', name:'Olivia', cat:'minecraft', head:'#8B5E3C', torso:'#CC3333', legs:'#333333', arms:'#8B5E3C', headgear:'#333333', headgearType:'hair', accent:'#228B22', icon:'üîß' },
        { id:'mc_axel', name:'Axel', cat:'minecraft', head:'#DDBB88', torso:'#228B22', legs:'#444444', arms:'#DDBB88', headgear:'#333333', headgearType:'hair', accent:'#FFD500', icon:'üí™' },
        { id:'mc_lukas', name:'Lukas', cat:'minecraft', head:'#DDBB88', torso:'#FFD500', legs:'#0055BF', arms:'#DDBB88', headgear:'#FFD500', headgearType:'hair', accent:'#FFFFFF', icon:'üìñ' },
        { id:'mc_ivor', name:'Ivor', cat:'minecraft', head:'#DDBB88', torso:'#666666', legs:'#444444', arms:'#DDBB88', headgear:'#444444', headgearType:'hair', accent:'#9933CC', icon:'‚öóÔ∏è' },
        { id:'mc_gabriel', name:'Gabriel the Warrior', cat:'minecraft', head:'#DDBB88', torso:'#CCCCCC', legs:'#555555', arms:'#CCCCCC', headgear:'#CCCCCC', headgearType:'helmet', accent:'#0055BF', icon:'üõ°Ô∏è' },
        { id:'mc_soren', name:'Soren the Architect', cat:'minecraft', head:'#DDBB88', torso:'#0088CC', legs:'#333333', arms:'#DDBB88', headgear:'#884400', headgearType:'hair', accent:'#FFD500', icon:'üèóÔ∏è' },
        { id:'mc_ellegaard', name:'Ellegaard', cat:'minecraft', head:'#DDBB88', torso:'#CC3333', legs:'#333333', arms:'#DDBB88', headgear:'#333333', headgearType:'hair', accent:'#FF6600', icon:'üíé' },
        { id:'mc_magnus', name:'Magnus the Rogue', cat:'minecraft', head:'#DDBB88', torso:'#228B22', legs:'#333333', arms:'#DDBB88', headgear:null, headgearType:null, accent:'#111111', icon:'üí•' },
        { id:'mc_harper', name:'Harper', cat:'minecraft', head:'#DDBB88', torso:'#6644AA', legs:'#333333', arms:'#DDBB88', headgear:'#6644AA', headgearType:'hair', accent:'#FFFFFF', icon:'üî¨' },
        { id:'mc_jack', name:'Jack', cat:'minecraft', head:'#DDBB88', torso:'#886644', legs:'#444444', arms:'#DDBB88', headgear:'#886644', headgearType:'hat', accent:'#8B5E3C', icon:'ü§†' },
        { id:'mc_nurm', name:'Nurm', cat:'minecraft', head:'#BBBBBB', torso:'#228B22', legs:'#228B22', arms:'#BBBBBB', headgear:'#228B22', headgearType:'hat', accent:'#FFD500', icon:'üßë‚Äçüåæ' },
        { id:'mc_stella', name:'Stella', cat:'minecraft', head:'#DDBB88', torso:'#FF88CC', legs:'#333333', arms:'#DDBB88', headgear:'#FFD500', headgearType:'hair', accent:'#FF44AA', icon:'üëë' },
        { id:'mc_radar', name:'Radar', cat:'minecraft', head:'#8B5E3C', torso:'#0088CC', legs:'#333333', arms:'#8B5E3C', headgear:'#333333', headgearType:'hair', accent:'#FFFFFF', icon:'üì°' },
        { id:'mc_admin', name:'The Admin (Romeo)', cat:'minecraft', head:'#CC3333', torso:'#CC0000', legs:'#880000', arms:'#CC3333', headgear:'#CC0000', headgearType:'crown', accent:'#FFD500', icon:'üëø' },
        { id:'mc_xara', name:'Xara', cat:'minecraft', head:'#DDBB88', torso:'#444444', legs:'#333333', arms:'#DDBB88', headgear:'#111111', headgearType:'hair', accent:'#00AAAA', icon:'‚ö°' },
        { id:'mc_fred', name:'Fred', cat:'minecraft', head:'#8B5E3C', torso:'#FFD500', legs:'#886644', arms:'#8B5E3C', headgear:'#333333', headgearType:'hair', accent:'#FFD500', icon:'üòä' },
        // --- Minecraft Armor & Special Variants ---
        { id:'mc_steve_diamond', name:'Steve Diamond Armor', cat:'minecraft', head:'#DDBB88', torso:'#44BBBB', legs:'#44BBBB', arms:'#44BBBB', headgear:'#44BBBB', headgearType:'helmet', accent:'#22AAAA', icon:'üíé' },
        { id:'mc_steve_netherite', name:'Steve Netherite Armor', cat:'minecraft', head:'#DDBB88', torso:'#443333', legs:'#443333', arms:'#443333', headgear:'#443333', headgearType:'helmet', accent:'#332222', icon:'üõ°Ô∏è' },
        { id:'mc_steve_iron', name:'Steve Iron Armor', cat:'minecraft', head:'#DDBB88', torso:'#CCCCCC', legs:'#CCCCCC', arms:'#CCCCCC', headgear:'#CCCCCC', headgearType:'helmet', accent:'#AAAAAA', icon:'‚öîÔ∏è' },
        { id:'mc_steve_gold', name:'Steve Gold Armor', cat:'minecraft', head:'#DDBB88', torso:'#FFD500', legs:'#FFD500', arms:'#FFD500', headgear:'#FFD500', headgearType:'helmet', accent:'#DDAA00', icon:'‚ú®' },
        { id:'mc_alex_diamond', name:'Alex Diamond Armor', cat:'minecraft', head:'#DDBB88', torso:'#44BBBB', legs:'#44BBBB', arms:'#44BBBB', headgear:'#44BBBB', headgearType:'helmet', accent:'#FF8833', icon:'üíé' },
        // === ROBLOX (25) ===
        { id:'rb_noob', name:'Noob', cat:'roblox', head:'#FFD500', torso:'#0055BF', legs:'#228B22', arms:'#FFD500', headgear:null, headgearType:null, accent:null, icon:'üü®' },
        { id:'rb_guest', name:'Guest', cat:'roblox', head:'#CCCCCC', torso:'#333333', legs:'#555555', arms:'#CCCCCC', headgear:null, headgearType:null, accent:'#CC0000', icon:'üë§' },
        { id:'rb_bacon', name:'Bacon Hair', cat:'roblox', head:'#FFD500', torso:'#333333', legs:'#222222', arms:'#FFD500', headgear:'#993300', headgearType:'hair', accent:null, icon:'ü•ì' },
        { id:'rb_builderman', name:'Builderman', cat:'roblox', head:'#FFD500', torso:'#CC0000', legs:'#0055BF', arms:'#FFD500', headgear:'#8B5E3C', headgearType:'hair', accent:null, icon:'üî®' },
        { id:'rb_dominus', name:'Dominus', cat:'roblox', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#FFD500', headgear:'#FFFFFF', headgearType:'crown', accent:'#FFD500', icon:'üëë' },
        { id:'rb_korblox', name:'Korblox Knight', cat:'roblox', head:'#3344FF', torso:'#222255', legs:'#111133', arms:'#3344FF', headgear:'#222255', headgearType:'helmet', accent:'#3344FF', icon:'‚öîÔ∏è' },
        { id:'rb_headless', name:'Headless', cat:'roblox', head:'#111111', torso:'#222222', legs:'#222222', arms:'#222222', headgear:null, headgearType:null, accent:'#444444', icon:'üí´' },
        { id:'rb_rthro_knight', name:'Rthro Knight', cat:'roblox', head:'#FFD500', torso:'#C0C0C0', legs:'#888888', arms:'#C0C0C0', headgear:'#C0C0C0', headgearType:'helmet', accent:'#CC0000', icon:'üõ°Ô∏è' },
        { id:'rb_jailbreak', name:'Jailbreak Cop', cat:'roblox', head:'#FFD500', torso:'#0055BF', legs:'#333333', arms:'#FFD500', headgear:'#0055BF', headgearType:'hat', accent:'#C0C0C0', icon:'üëÆ' },
        { id:'rb_jailbreak_crim', name:'Jailbreak Crim', cat:'roblox', head:'#FFD500', torso:'#FF6600', legs:'#FF6600', arms:'#FFD500', headgear:null, headgearType:null, accent:'#111111', icon:'ü¶π' },
        { id:'rb_adopt_me', name:'Adopt Me Player', cat:'roblox', head:'#FFD500', torso:'#FF69B4', legs:'#FFFFFF', arms:'#FFD500', headgear:'#FF69B4', headgearType:'hat', accent:'#FF69B4', icon:'üê£' },
        { id:'rb_bloxburg', name:'Bloxburg', cat:'roblox', head:'#FFD500', torso:'#FFFFFF', legs:'#0055BF', arms:'#FFD500', headgear:'#8B5E3C', headgearType:'hair', accent:null, icon:'üè†' },
        { id:'rb_tower_heroes', name:'Tower Hero', cat:'roblox', head:'#FFD500', torso:'#CC0000', legs:'#FFD500', arms:'#FFD500', headgear:'#CC0000', headgearType:'helmet', accent:'#FFFFFF', icon:'üóº' },
        { id:'rb_brookhaven', name:'Brookhaven', cat:'roblox', head:'#FFD500', torso:'#228B22', legs:'#111111', arms:'#FFD500', headgear:'#111111', headgearType:'hair', accent:null, icon:'üèòÔ∏è' },
        { id:'rb_mm2_sheriff', name:'MM2 Sheriff', cat:'roblox', head:'#FFD500', torso:'#8B5E3C', legs:'#0055BF', arms:'#FFD500', headgear:'#8B5E3C', headgearType:'hat', accent:'#C0C0C0', icon:'üî´' },
        { id:'rb_mm2_murderer', name:'MM2 Murderer', cat:'roblox', head:'#FFD500', torso:'#CC0000', legs:'#111111', arms:'#CC0000', headgear:'#CC0000', headgearType:'mask', accent:'#111111', icon:'üî™' },
        { id:'rb_doors_seek', name:'Doors Seek', cat:'roblox', head:'#111111', torso:'#111111', legs:'#111111', arms:'#111111', headgear:null, headgearType:null, accent:'#CC0000', icon:'üëÅÔ∏è' },
        { id:'rb_doors_figure', name:'Doors Figure', cat:'roblox', head:'#333333', torso:'#222222', legs:'#222222', arms:'#333333', headgear:null, headgearType:null, accent:'#FFFFFF', icon:'üö™' },
        { id:'rb_blox_fruits', name:'Blox Fruits', cat:'roblox', head:'#FFD500', torso:'#CC0000', legs:'#111111', arms:'#FFD500', headgear:'#FFD500', headgearType:'hat', accent:'#FFD500', icon:'üçé' },
        { id:'rb_king_legacy', name:'King Legacy', cat:'roblox', head:'#FFD500', torso:'#FFD500', legs:'#CC0000', arms:'#FFD500', headgear:'#FFD500', headgearType:'crown', accent:'#CC0000', icon:'üëë' },
        { id:'rb_anime_fight', name:'Anime Fighter', cat:'roblox', head:'#FFD500', torso:'#FF6600', legs:'#0055BF', arms:'#FFD500', headgear:'#FF6600', headgearType:'hair', accent:'#FF6600', icon:'üí™' },
        { id:'rb_pet_sim', name:'Pet Sim X', cat:'roblox', head:'#FFD500', torso:'#FF69B4', legs:'#FF69B4', arms:'#FFD500', headgear:null, headgearType:null, accent:'#FFD500', icon:'üê∂' },
        { id:'rb_bedwars', name:'Bedwars', cat:'roblox', head:'#FFD500', torso:'#CC0000', legs:'#333333', arms:'#CC0000', headgear:'#CC0000', headgearType:'helmet', accent:'#FFFFFF', icon:'üõèÔ∏è' },
        { id:'rb_arsenal', name:'Arsenal', cat:'roblox', head:'#FFD500', torso:'#444444', legs:'#333333', arms:'#FFD500', headgear:'#444444', headgearType:'helmet', accent:'#FF6600', icon:'üî´' },
        { id:'rb_shindo', name:'Shindo Life', cat:'roblox', head:'#FFD500', torso:'#FF6600', legs:'#111111', arms:'#FFD500', headgear:'#FF6600', headgearType:'mask', accent:'#CC0000', icon:'üåÄ' },
        // === ANIME (20) ===
        { id:'an_naruto', name:'Naruto', cat:'anime', head:'#FFD500', torso:'#FF6600', legs:'#FF6600', arms:'#FFD500', headgear:'#FFD500', headgearType:'hair', accent:'#0055BF', icon:'üç•' },
        { id:'an_sasuke', name:'Sasuke', cat:'anime', head:'#FFD500', torso:'#111111', legs:'#FFFFFF', arms:'#FFD500', headgear:'#111111', headgearType:'hair', accent:'#6B2FA0', icon:'‚ö°' },
        { id:'an_sakura', name:'Sakura', cat:'anime', head:'#FFD500', torso:'#CC0000', legs:'#111111', arms:'#FFD500', headgear:'#FF69B4', headgearType:'hair', accent:'#FF69B4', icon:'üå∏' },
        { id:'an_kakashi', name:'Kakashi', cat:'anime', head:'#FFD500', torso:'#228B22', legs:'#0055BF', arms:'#FFD500', headgear:'#C0C0C0', headgearType:'mask', accent:'#111111', icon:'üìñ' },
        { id:'an_goku', name:'Goku', cat:'anime', head:'#FFD500', torso:'#FF6600', legs:'#0055BF', arms:'#FFD500', headgear:'#111111', headgearType:'hair', accent:'#0055BF', icon:'üêâ' },
        { id:'an_vegeta', name:'Vegeta', cat:'anime', head:'#FFD500', torso:'#0055BF', legs:'#FFFFFF', arms:'#FFD500', headgear:'#111111', headgearType:'hair', accent:'#FFD500', icon:'üëä' },
        { id:'an_goku_ssj', name:'SSJ Goku', cat:'anime', head:'#FFD500', torso:'#FF6600', legs:'#0055BF', arms:'#FFD500', headgear:'#FFD500', headgearType:'hair', accent:'#FFDD00', icon:'‚ö°' },
        { id:'an_luffy', name:'Luffy', cat:'anime', head:'#FFD500', torso:'#CC0000', legs:'#0055BF', arms:'#FFD500', headgear:'#CC0000', headgearType:'hat', accent:null, icon:'üè¥‚Äç‚ò†Ô∏è' },
        { id:'an_zoro', name:'Zoro', cat:'anime', head:'#FFD500', torso:'#228B22', legs:'#111111', arms:'#FFD500', headgear:'#228B22', headgearType:'hair', accent:'#228B22', icon:'‚öîÔ∏è' },
        { id:'an_sanji', name:'Sanji', cat:'anime', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#FFD500', headgear:'#FFD500', headgearType:'hair', accent:null, icon:'üç≥' },
        { id:'an_ichigo', name:'Ichigo', cat:'anime', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#FFD500', headgear:'#FF6600', headgearType:'hair', accent:'#CC0000', icon:'‚öîÔ∏è' },
        { id:'an_tanjiro', name:'Tanjiro', cat:'anime', head:'#FFD500', torso:'#228B22', legs:'#111111', arms:'#FFD500', headgear:'#8B0000', headgearType:'hair', accent:'#CC0000', icon:'üî•' },
        { id:'an_nezuko', name:'Nezuko', cat:'anime', head:'#FFD500', torso:'#FF69B4', legs:'#FF69B4', arms:'#FFD500', headgear:'#111111', headgearType:'hair', accent:'#FF69B4', icon:'üå∏' },
        { id:'an_deku', name:'Deku', cat:'anime', head:'#FFD500', torso:'#228B22', legs:'#FFFFFF', arms:'#FFD500', headgear:'#228B22', headgearType:'hair', accent:'#CC0000', icon:'üí™' },
        { id:'an_todoroki', name:'Todoroki', cat:'anime', head:'#FFD500', torso:'#0055BF', legs:'#0055BF', arms:'#FFD500', headgear:'#CC0000', headgearType:'hair', accent:'#FFFFFF', icon:'üî•' },
        { id:'an_allmight', name:'All Might', cat:'anime', head:'#FFD500', torso:'#0055BF', legs:'#CC0000', arms:'#FFD500', headgear:'#FFD500', headgearType:'hair', accent:'#FFFFFF', icon:'üí™' },
        { id:'an_saitama', name:'Saitama', cat:'anime', head:'#FFD500', torso:'#FFD500', legs:'#CC0000', arms:'#FFD500', headgear:null, headgearType:null, accent:'#FFFFFF', icon:'üëä' },
        { id:'an_genos', name:'Genos', cat:'anime', head:'#FFD500', torso:'#111111', legs:'#333333', arms:'#C0C0C0', headgear:'#FFD500', headgearType:'hair', accent:'#FF6600', icon:'ü§ñ' },
        { id:'an_eren', name:'Eren Yeager', cat:'anime', head:'#FFD500', torso:'#A0522D', legs:'#FFFFFF', arms:'#FFD500', headgear:'#8B5E3C', headgearType:'hair', accent:'#228B22', icon:'‚öîÔ∏è' },
        { id:'an_levi', name:'Levi', cat:'anime', head:'#FFD500', torso:'#A0522D', legs:'#FFFFFF', arms:'#FFD500', headgear:'#111111', headgearType:'hair', accent:'#228B22', icon:'‚öîÔ∏è' },
        // === NINTENDO (18) ===
        { id:'ni_mario', name:'Mario', cat:'nintendo', head:'#FFD500', torso:'#CC0000', legs:'#0055BF', arms:'#CC0000', headgear:'#CC0000', headgearType:'hat', accent:'#FFFFFF', icon:'üçÑ' },
        { id:'ni_luigi', name:'Luigi', cat:'nintendo', head:'#FFD500', torso:'#228B22', legs:'#0055BF', arms:'#228B22', headgear:'#228B22', headgearType:'hat', accent:'#FFFFFF', icon:'üçÑ' },
        { id:'ni_peach', name:'Peach', cat:'nintendo', head:'#FFD500', torso:'#FF69B4', legs:'#FF69B4', arms:'#FFD500', headgear:'#FFD500', headgearType:'crown', accent:'#FFD500', icon:'üë∏' },
        { id:'ni_toad', name:'Toad', cat:'nintendo', head:'#FFFFFF', torso:'#0055BF', legs:'#FFFFFF', arms:'#FFFFFF', headgear:'#CC0000', headgearType:'hat', accent:'#FFFFFF', icon:'üçÑ' },
        { id:'ni_bowser', name:'Bowser', cat:'nintendo', head:'#FFD500', torso:'#228B22', legs:'#FFD500', arms:'#FFD500', headgear:'#CC0000', headgearType:'horns', accent:'#228B22', icon:'üê¢' },
        { id:'ni_yoshi', name:'Yoshi', cat:'nintendo', head:'#228B22', torso:'#FFFFFF', legs:'#FF6600', arms:'#228B22', headgear:null, headgearType:null, accent:'#CC0000', icon:'ü¶é' },
        { id:'ni_link', name:'Link', cat:'nintendo', head:'#FFD500', torso:'#228B22', legs:'#A0522D', arms:'#FFD500', headgear:'#228B22', headgearType:'hat', accent:'#228B22', icon:'üó°Ô∏è' },
        { id:'ni_zelda', name:'Zelda', cat:'nintendo', head:'#FFD500', torso:'#FFFFFF', legs:'#6B2FA0', arms:'#FFD500', headgear:'#FFD500', headgearType:'crown', accent:'#6B2FA0', icon:'üë∏' },
        { id:'ni_ganondorf', name:'Ganondorf', cat:'nintendo', head:'#228B22', torso:'#111111', legs:'#333333', arms:'#228B22', headgear:'#CC0000', headgearType:'crown', accent:'#CC0000', icon:'üëπ' },
        { id:'ni_pikachu', name:'Pikachu', cat:'nintendo', head:'#FFDD00', torso:'#FFDD00', legs:'#FFDD00', arms:'#FFDD00', headgear:null, headgearType:null, accent:'#CC0000', icon:'‚ö°' },
        { id:'ni_charizard', name:'Charizard', cat:'nintendo', head:'#FF6600', torso:'#FF6600', legs:'#FF6600', arms:'#FF6600', headgear:'#FF6600', headgearType:'horns', accent:'#FFDD00', icon:'üî•' },
        { id:'ni_mewtwo', name:'Mewtwo', cat:'nintendo', head:'#CCAAFF', torso:'#CCAAFF', legs:'#CCAAFF', arms:'#CCAAFF', headgear:null, headgearType:null, accent:'#6B2FA0', icon:'üîÆ' },
        { id:'ni_kirby', name:'Kirby', cat:'nintendo', head:'#FF69B4', torso:'#FF69B4', legs:'#CC0000', arms:'#FF69B4', headgear:null, headgearType:null, accent:'#CC0000', icon:'‚≠ê' },
        { id:'ni_samus', name:'Samus', cat:'nintendo', head:'#FFD500', torso:'#FF6600', legs:'#FF6600', arms:'#FF6600', headgear:'#FF6600', headgearType:'helmet', accent:'#228B22', icon:'üöÄ' },
        { id:'ni_dk', name:'Donkey Kong', cat:'nintendo', head:'#8B5E3C', torso:'#8B5E3C', legs:'#8B5E3C', arms:'#8B5E3C', headgear:null, headgearType:null, accent:'#CC0000', icon:'ü¶ç' },
        { id:'ni_inkling', name:'Inkling', cat:'nintendo', head:'#FF6600', torso:'#FF6600', legs:'#111111', arms:'#FF6600', headgear:'#FF6600', headgearType:'hair', accent:'#FFD500', icon:'ü¶ë' },
        { id:'ni_villager_ac', name:'AC Villager', cat:'nintendo', head:'#FFD500', torso:'#CC0000', legs:'#A0522D', arms:'#FFD500', headgear:'#8B5E3C', headgearType:'hair', accent:null, icon:'üèùÔ∏è' },
        { id:'ni_isabelle', name:'Isabelle', cat:'nintendo', head:'#FFDD88', torso:'#228B22', legs:'#228B22', arms:'#FFDD88', headgear:'#FFDD88', headgearType:'hair', accent:'#CC0000', icon:'üêï' },
        // === FORTNITE (15) ===
        { id:'fn_jonesy', name:'Jonesy', cat:'fortnite', head:'#FFD500', torso:'#555555', legs:'#555555', arms:'#FFD500', headgear:'#FFD500', headgearType:'hair', accent:null, icon:'üî´' },
        { id:'fn_ramirez', name:'Ramirez', cat:'fortnite', head:'#8B5E3C', torso:'#555555', legs:'#555555', arms:'#8B5E3C', headgear:'#111111', headgearType:'hair', accent:null, icon:'üî´' },
        { id:'fn_peely', name:'Peely', cat:'fortnite', head:'#FFDD00', torso:'#FFDD00', legs:'#FFDD00', arms:'#FFDD00', headgear:null, headgearType:null, accent:'#8B5E3C', icon:'üçå' },
        { id:'fn_fishstick', name:'Fishstick', cat:'fortnite', head:'#4488CC', torso:'#FF6600', legs:'#FF6600', arms:'#4488CC', headgear:null, headgearType:null, accent:'#FFD500', icon:'üêü' },
        { id:'fn_skull_trooper', name:'Skull Trooper', cat:'fortnite', head:'#111111', torso:'#111111', legs:'#111111', arms:'#111111', headgear:'#111111', headgearType:'mask', accent:'#FFFFFF', icon:'üíÄ' },
        { id:'fn_raven', name:'Raven', cat:'fortnite', head:'#333366', torso:'#222244', legs:'#222244', arms:'#333366', headgear:'#222244', headgearType:'mask', accent:'#6B2FA0', icon:'üê¶‚Äç‚¨õ' },
        { id:'fn_drift', name:'Drift', cat:'fortnite', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#FFD500', headgear:'#FF69B4', headgearType:'mask', accent:'#FF69B4', icon:'üåÄ' },
        { id:'fn_midas', name:'Midas', cat:'fortnite', head:'#FFD500', torso:'#111111', legs:'#333333', arms:'#FFD500', headgear:'#FFD500', headgearType:'hair', accent:'#FFD500', icon:'üëë' },
        { id:'fn_meowscles', name:'Meowscles', cat:'fortnite', head:'#888888', torso:'#888888', legs:'#0055BF', arms:'#888888', headgear:null, headgearType:null, accent:'#333333', icon:'üê±' },
        { id:'fn_kit', name:'Kit', cat:'fortnite', head:'#888888', torso:'#C0C0C0', legs:'#C0C0C0', arms:'#888888', headgear:null, headgearType:null, accent:'#FF6600', icon:'üê±' },
        { id:'fn_omega', name:'Omega', cat:'fortnite', head:'#333333', torso:'#222222', legs:'#222222', arms:'#333333', headgear:'#333333', headgearType:'helmet', accent:'#FF6600', icon:'‚ö°' },
        { id:'fn_ice_king', name:'Ice King', cat:'fortnite', head:'#0055BF', torso:'#0044AA', legs:'#003388', arms:'#0055BF', headgear:'#88CCFF', headgearType:'crown', accent:'#88CCFF', icon:'‚ùÑÔ∏è' },
        { id:'fn_lynx', name:'Lynx', cat:'fortnite', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#FFD500', headgear:'#111111', headgearType:'mask', accent:'#CC0000', icon:'üê±' },
        { id:'fn_marshmello', name:'Marshmello', cat:'fortnite', head:'#FFFFFF', torso:'#FFFFFF', legs:'#FFFFFF', arms:'#FFFFFF', headgear:'#FFFFFF', headgearType:'helmet', accent:'#111111', icon:'üéµ' },
        { id:'fn_travis', name:'Travis Scott', cat:'fortnite', head:'#8B5E3C', torso:'#111111', legs:'#A0522D', arms:'#8B5E3C', headgear:'#111111', headgearType:'hair', accent:'#FF6600', icon:'üé§' },
        // === OTHER (expanded 20) ===
        { id:'ninja_red', name:'Red Ninja', cat:'other', head:'#FFD500', torso:'#CC0000', legs:'#111111', arms:'#CC0000', headgear:'#CC0000', headgearType:'mask', accent:'#FFD500', icon:'ü•∑' },
        { id:'ninja_black', name:'Black Ninja', cat:'other', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#111111', headgear:'#111111', headgearType:'mask', accent:'#C0C0C0', icon:'ü•∑' },
        { id:'ninja_blue', name:'Blue Ninja', cat:'other', head:'#FFD500', torso:'#0055BF', legs:'#111111', arms:'#0055BF', headgear:'#0055BF', headgearType:'mask', accent:'#FFFFFF', icon:'ü•∑' },
        { id:'ninja_green', name:'Green Ninja', cat:'other', head:'#FFD500', torso:'#228B22', legs:'#111111', arms:'#228B22', headgear:'#228B22', headgearType:'mask', accent:'#FFD500', icon:'ü•∑' },
        { id:'pirate', name:'Pirate Captain', cat:'other', head:'#FFD500', torso:'#CC0000', legs:'#8B5E3C', arms:'#FFD500', headgear:'#111111', headgearType:'hat', accent:'#FFD500', icon:'üè¥‚Äç‚ò†Ô∏è' },
        { id:'knight', name:'Knight', cat:'other', head:'#FFD500', torso:'#C0C0C0', legs:'#C0C0C0', arms:'#C0C0C0', headgear:'#C0C0C0', headgearType:'helmet', accent:'#0055BF', icon:'üó°Ô∏è' },
        { id:'wizard', name:'Wizard', cat:'other', head:'#FFD500', torso:'#6B2FA0', legs:'#6B2FA0', arms:'#FFD500', headgear:'#0055BF', headgearType:'hat', accent:'#FFD500', icon:'üßô' },
        { id:'astronaut', name:'Astronaut', cat:'other', head:'#FFD500', torso:'#FFFFFF', legs:'#FFFFFF', arms:'#FFFFFF', headgear:'#FFFFFF', headgearType:'helmet', accent:'#FF8C00', icon:'üßë‚ÄçüöÄ' },
        { id:'firefighter', name:'Firefighter', cat:'other', head:'#FFD500', torso:'#111111', legs:'#111111', arms:'#FFD500', headgear:'#CC0000', headgearType:'helmet', accent:'#FFD500', icon:'üßë‚Äçüöí' },
        { id:'police', name:'Police Officer', cat:'other', head:'#FFD500', torso:'#0055BF', legs:'#111111', arms:'#FFD500', headgear:'#111111', headgearType:'hat', accent:'#C0C0C0', icon:'üëÆ' },
        { id:'doctor', name:'Doctor', cat:'other', head:'#FFD500', torso:'#FFFFFF', legs:'#FFFFFF', arms:'#FFD500', headgear:null, headgearType:null, accent:'#0055BF', icon:'üßë‚Äç‚öïÔ∏è' },
        { id:'chef', name:'Chef', cat:'other', head:'#FFD500', torso:'#FFFFFF', legs:'#111111', arms:'#FFD500', headgear:'#FFFFFF', headgearType:'hat', accent:null, icon:'üë®‚Äçüç≥' },
        { id:'zombie', name:'Zombie', cat:'other', head:'#228B22', torso:'#555555', legs:'#555555', arms:'#228B22', headgear:null, headgearType:null, accent:'#CC0000', icon:'üßü' },
        { id:'skeleton', name:'Skeleton', cat:'other', head:'#FFFFFF', torso:'#111111', legs:'#111111', arms:'#FFFFFF', headgear:null, headgearType:null, accent:'#FFFFFF', icon:'üíÄ' },
        { id:'robot', name:'Robot', cat:'other', head:'#C0C0C0', torso:'#C0C0C0', legs:'#C0C0C0', arms:'#C0C0C0', headgear:null, headgearType:null, accent:'#CC0000', icon:'ü§ñ' },
        { id:'alien', name:'Alien', cat:'other', head:'#228B22', torso:'#6B2FA0', legs:'#6B2FA0', arms:'#228B22', headgear:null, headgearType:null, accent:'#00FF00', icon:'üëΩ' },
        { id:'vampire', name:'Vampire', cat:'other', head:'#FFFFFF', torso:'#111111', legs:'#111111', arms:'#FFFFFF', headgear:'#111111', headgearType:'hair', accent:'#CC0000', icon:'üßõ' },
        { id:'werewolf', name:'Werewolf', cat:'other', head:'#8B5E3C', torso:'#666666', legs:'#555555', arms:'#8B5E3C', headgear:null, headgearType:null, accent:'#FFD500', icon:'üê∫' },
        { id:'mummy', name:'Mummy', cat:'other', head:'#D2B48C', torso:'#D2B48C', legs:'#D2B48C', arms:'#D2B48C', headgear:null, headgearType:null, accent:'#228B22', icon:'üßü' },
        { id:'santa', name:'Santa Claus', cat:'other', head:'#FFD500', torso:'#CC0000', legs:'#CC0000', arms:'#FFD500', headgear:'#CC0000', headgearType:'hat', accent:'#FFFFFF', icon:'üéÖ' },
    ];

    let selectedMinifig = null;

    function renderMinifigGrid(chars) {
        const grid = document.getElementById('minifig-grid');
        if (!grid) return;
        grid.innerHTML = '';
        chars.forEach(ch => {
            const card = document.createElement('div');
            card.className = 'minifig-card' + (selectedMinifig === ch.id ? ' selected' : '');
            card.dataset.minifigId = ch.id;
            card.onclick = () => selectMinifig(ch.id);
            card.ondblclick = () => { selectMinifig(ch.id); placeSelectedMinifig(); };
            card.title = ch.name + ' (click to select, then click baseplate to place)';

            const hg = ch.headgear ? `<div class="mf-headgear" style="background:${ch.headgear};${ch.headgearType==='crown'?'border-radius:2px;height:6px;':''}${ch.headgearType==='hat'?'height:10px;border-radius:6px 6px 0 0;width:22px;':''}${ch.headgearType==='horns'?'height:5px;width:24px;border-radius:2px;':''}"></div>` : '';
            const accentDot = ch.accent ? `<div style="position:absolute;width:6px;height:6px;background:${ch.accent};border-radius:50%;top:4px;left:50%;transform:translateX(-50%);"></div>` : '';

            card.innerHTML = `
                <div class="minifig-preview">
                    <div style="position:relative;display:inline-block;">
                        ${hg}
                        <div class="mf-head" style="background:${ch.head};"></div>
                    </div>
                    <div style="position:relative;display:inline-block;">
                        <div class="mf-arm-l" style="background:${ch.arms};"></div>
                        <div class="mf-torso" style="background:${ch.torso};">${accentDot}</div>
                        <div class="mf-arm-r" style="background:${ch.arms};"></div>
                    </div>
                    <div class="mf-legs">
                        <div class="mf-leg" style="background:${ch.legs};"></div>
                        <div class="mf-leg" style="background:${ch.legs};"></div>
                    </div>
                </div>
                <div class="mf-name">${ch.icon} ${ch.name}</div>
                <div class="mf-cat">${ch.cat}</div>
            `;
            grid.appendChild(card);
        });
    }

    function filterMinifigs(query) {
        const q = query.toLowerCase();
        const filtered = MINIFIG_CHARACTERS.filter(ch =>
            ch.name.toLowerCase().includes(q) || ch.cat.toLowerCase().includes(q) || ch.id.includes(q)
        );
        renderMinifigGrid(filtered);
    }

    function filterMinifigCat(cat, btn) {
        document.querySelectorAll('.minifig-cat-btn').forEach(b => b.classList.remove('active'));
        if (btn) btn.classList.add('active');
        const searchVal = document.getElementById('minifig-search');
        if (searchVal) searchVal.value = '';
        if (cat === 'all') {
            renderMinifigGrid(MINIFIG_CHARACTERS);
        } else {
            renderMinifigGrid(MINIFIG_CHARACTERS.filter(ch => ch.cat === cat));
        }
    }

    function selectMinifig(id) {
        selectedMinifig = id;
        state.placementMode = 'minifig';
        // Update card selection
        document.querySelectorAll('.minifig-card').forEach(c => c.classList.remove('selected'));
        const allCards = document.querySelectorAll('.minifig-card');
        allCards.forEach(c => {
            if (c.dataset.minifigId === id) c.classList.add('selected');
        });
        const ch = MINIFIG_CHARACTERS.find(c => c.id === id);
        if (ch) showToast(`${ch.icon} ${ch.name} selected ‚Äî click baseplate to place!`, 'info');
        // Remove ghost brick, show ghost minifig instead
        if (ghostBrick) { scene.remove(ghostBrick); ghostBrick = null; }
        updateGhostMinifig();
        updateModeIndicator();
    }

    function switchToBrickMode() {
        state.placementMode = 'brick';
        selectedMinifig = null;
        document.querySelectorAll('.minifig-card').forEach(c => c.classList.remove('selected'));
        if (ghostMinifig) { scene.remove(ghostMinifig); ghostMinifig = null; }
        createGhostBrick();
        updateModeIndicator();
    }

    function updateModeIndicator() {
        let indicator = document.getElementById('mode-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'mode-indicator';
            indicator.style.cssText = 'position:absolute;top:10px;left:50%;transform:translateX(-50%);padding:8px 20px;border-radius:20px;font-size:14px;font-weight:bold;z-index:100;pointer-events:auto;cursor:pointer;transition:all 0.3s;';
            const viewport = document.getElementById('viewport');
            if (viewport) viewport.appendChild(indicator);
        }
        if (state.placementMode === 'preset' && state.presetData) {
            indicator.innerHTML = `üìã PRESET MODE: ${state.presetName || 'Design'} <span style="opacity:0.6;font-size:12px">(click anywhere to place, ESC to exit)</span>`;
            indicator.style.background = 'linear-gradient(135deg, #f0a500, #c78500)';
            indicator.style.color = '#fff';
            indicator.style.border = '2px solid #ffd700';
            indicator.style.display = 'block';
            indicator.onclick = switchToBrickModeFromPreset;
        } else if (state.placementMode === 'minifig' && selectedMinifig) {
            const ch = MINIFIG_CHARACTERS.find(c => c.id === selectedMinifig);
            indicator.innerHTML = `${ch ? ch.icon : 'üßë'} MINIFIG MODE: ${ch ? ch.name : 'Custom'} <span style="opacity:0.6;font-size:12px">(click to switch to bricks)</span>`;
            indicator.style.background = 'linear-gradient(135deg, #e94560, #c23152)';
            indicator.style.color = '#fff';
            indicator.style.border = '2px solid #ff6b81';
            indicator.style.display = 'block';
            indicator.onclick = switchToBrickMode;
        } else {
            indicator.innerHTML = 'üß± BRICK MODE <span style="opacity:0.6;font-size:12px">(select a minifig to switch)</span>';
            indicator.style.background = 'linear-gradient(135deg, #0f3460, #16213e)';
            indicator.style.color = '#aaa';
            indicator.style.border = '2px solid #2a2a4a';
            indicator.style.display = 'block';
            indicator.onclick = null;
        }
    }

    function updateGhostMinifig() {
        if (ghostMinifig) { scene.remove(ghostMinifig); ghostMinifig = null; }
        if (state.placementMode !== 'minifig' || !selectedMinifig) return;
        const charDef = MINIFIG_CHARACTERS.find(c => c.id === selectedMinifig);
        if (!charDef) return;
        ghostMinifig = createMinifigure3D(charDef);
        // Make it transparent
        ghostMinifig.traverse(child => {
            if (child.isMesh && child.material) {
                child.material = child.material.clone();
                child.material.transparent = true;
                child.material.opacity = 0.5;
            }
        });
        const gx = state.cursorX || 16;
        const gz = state.cursorZ || 16;
        const autoLayer = getStackHeight(gx, gz);
        const layer = state.manualLayerMode && state.buildHeight > 0 ? state.buildHeight : autoLayer;
        ghostMinifig.position.set(gx * UNIT + UNIT / 2, layer * HEIGHT, gz * UNIT + UNIT / 2);
        // Apply rotation
        ghostMinifig.rotation.y = (state.rotation * Math.PI) / 180;
        scene.add(ghostMinifig);
    }

    // ========== 3D MINIFIGURE GEOMETRY ==========
    function createMinifigure3D(charDef) {
        const group = new THREE.Group();
        const S = UNIT; // scale factor = 8mm per unit

        // -- HEAD (sphere-ish cylinder, LEGO style) --
        const headGeo = new THREE.CylinderGeometry(S * 0.5, S * 0.5, S * 0.75, 16);
        const headMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(charDef.head), roughness: 0.5, metalness: 0.1 });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.set(0, S * 2.6, 0);
        head.castShadow = true;
        group.add(head);

        // Head stud on top
        const headStudGeo = new THREE.CylinderGeometry(STUD_R * 0.6, STUD_R * 0.6, STUD_H * 0.5, 8);
        const headStudMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(charDef.head).multiplyScalar(1.1), roughness: 0.5 });
        const headStud = new THREE.Mesh(headStudGeo, headStudMat);
        headStud.position.set(0, S * 3.05, 0);
        headStud.castShadow = true;
        group.add(headStud);

        // Face details (eyes + mouth)
        const eyeGeo = new THREE.SphereGeometry(S * 0.07, 6, 6);
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
        eyeL.position.set(-S * 0.15, S * 2.65, S * 0.48);
        group.add(eyeL);
        const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
        eyeR.position.set(S * 0.15, S * 2.65, S * 0.48);
        group.add(eyeR);
        // Smile
        const smileGeo = new THREE.TorusGeometry(S * 0.12, S * 0.025, 4, 8, Math.PI);
        const smileMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const smile = new THREE.Mesh(smileGeo, smileMat);
        smile.position.set(0, S * 2.5, S * 0.48);
        smile.rotation.x = Math.PI;
        group.add(smile);

        // -- HEADGEAR --
        if (charDef.headgear && charDef.headgearType) {
            const hgColor = new THREE.Color(charDef.headgear);
            let hgMesh;
            if (charDef.headgearType === 'helmet') {
                const hgGeo = new THREE.SphereGeometry(S * 0.58, 16, 12, 0, Math.PI * 2, 0, Math.PI * 0.65);
                const hgMat = new THREE.MeshStandardMaterial({ color: hgColor, roughness: 0.4, metalness: 0.3 });
                hgMesh = new THREE.Mesh(hgGeo, hgMat);
                hgMesh.position.set(0, S * 2.7, 0);
            } else if (charDef.headgearType === 'mask') {
                const hgGeo = new THREE.CylinderGeometry(S * 0.52, S * 0.52, S * 0.8, 16);
                const hgMat = new THREE.MeshStandardMaterial({ color: hgColor, roughness: 0.4 });
                hgMesh = new THREE.Mesh(hgGeo, hgMat);
                hgMesh.position.set(0, S * 2.6, 0);
                // Eye holes
                const holeGeo = new THREE.BoxGeometry(S * 0.4, S * 0.1, S * 0.15);
                const holeMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const holes = new THREE.Mesh(holeGeo, holeMat);
                holes.position.set(0, S * 2.65, S * 0.45);
                group.add(holes);
            } else if (charDef.headgearType === 'hair') {
                const hgGeo = new THREE.SphereGeometry(S * 0.55, 12, 8, 0, Math.PI * 2, 0, Math.PI * 0.5);
                const hgMat = new THREE.MeshStandardMaterial({ color: hgColor, roughness: 0.8 });
                hgMesh = new THREE.Mesh(hgGeo, hgMat);
                hgMesh.position.set(0, S * 2.85, 0);
            } else if (charDef.headgearType === 'crown') {
                const hgGeo = new THREE.CylinderGeometry(S * 0.45, S * 0.5, S * 0.3, 6);
                const hgMat = new THREE.MeshStandardMaterial({ color: hgColor, roughness: 0.3, metalness: 0.5 });
                hgMesh = new THREE.Mesh(hgGeo, hgMat);
                hgMesh.position.set(0, S * 3.1, 0);
            } else if (charDef.headgearType === 'hat') {
                // Brim + top
                const brimGeo = new THREE.CylinderGeometry(S * 0.7, S * 0.7, S * 0.08, 16);
                const topGeo = new THREE.CylinderGeometry(S * 0.4, S * 0.45, S * 0.4, 16);
                const hgMat = new THREE.MeshStandardMaterial({ color: hgColor, roughness: 0.6 });
                const brim = new THREE.Mesh(brimGeo, hgMat);
                brim.position.set(0, S * 3.0, 0);
                group.add(brim);
                hgMesh = new THREE.Mesh(topGeo, hgMat);
                hgMesh.position.set(0, S * 3.2, 0);
            } else if (charDef.headgearType === 'visor') {
                const hgGeo = new THREE.BoxGeometry(S * 0.6, S * 0.15, S * 0.15);
                const hgMat = new THREE.MeshStandardMaterial({ color: hgColor, roughness: 0.3, metalness: 0.2, transparent: true, opacity: 0.8 });
                hgMesh = new THREE.Mesh(hgGeo, hgMat);
                hgMesh.position.set(0, S * 2.65, S * 0.45);
            } else if (charDef.headgearType === 'horns') {
                const hornGeo = new THREE.ConeGeometry(S * 0.08, S * 0.4, 6);
                const hgMat = new THREE.MeshStandardMaterial({ color: hgColor, roughness: 0.5 });
                const hornL = new THREE.Mesh(hornGeo, hgMat);
                hornL.position.set(-S * 0.35, S * 3.15, 0);
                hornL.rotation.z = 0.3;
                group.add(hornL);
                const hornR = new THREE.Mesh(hornGeo, hgMat);
                hornR.position.set(S * 0.35, S * 3.15, 0);
                hornR.rotation.z = -0.3;
                group.add(hornR);
            } else if (charDef.headgearType === 'dome') {
                const hgGeo = new THREE.SphereGeometry(S * 0.5, 16, 12);
                const hgMat = new THREE.MeshStandardMaterial({ color: hgColor, roughness: 0.2, metalness: 0.4 });
                hgMesh = new THREE.Mesh(hgGeo, hgMat);
                hgMesh.position.set(0, S * 2.9, 0);
            } else if (charDef.headgearType === 'gem') {
                const hgGeo = new THREE.OctahedronGeometry(S * 0.15, 0);
                const hgMat = new THREE.MeshStandardMaterial({ color: hgColor, roughness: 0.1, metalness: 0.6 });
                hgMesh = new THREE.Mesh(hgGeo, hgMat);
                hgMesh.position.set(0, S * 3.15, 0);
            }
            if (hgMesh) {
                hgMesh.castShadow = true;
                group.add(hgMesh);
            }
        }

        // -- TORSO --
        const torsoGeo = new THREE.BoxGeometry(S * 1.0, S * 1.0, S * 0.6);
        const torsoMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(charDef.torso), roughness: 0.6, metalness: 0.05 });
        const torso = new THREE.Mesh(torsoGeo, torsoMat);
        torso.position.set(0, S * 1.75, 0);
        torso.castShadow = true;
        torso.receiveShadow = true;
        group.add(torso);

        // Torso accent (chest emblem/detail)
        if (charDef.accent) {
            const accentGeo = new THREE.BoxGeometry(S * 0.3, S * 0.3, S * 0.02);
            const accentMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(charDef.accent), roughness: 0.4 });
            const accentMesh = new THREE.Mesh(accentGeo, accentMat);
            accentMesh.position.set(0, S * 1.85, S * 0.31);
            group.add(accentMesh);
        }

        // -- ARMS --
        const armGeo = new THREE.BoxGeometry(S * 0.28, S * 0.85, S * 0.35);
        const armMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(charDef.arms), roughness: 0.6 });
        // Left arm
        const armL = new THREE.Mesh(armGeo, armMat);
        armL.position.set(-S * 0.65, S * 1.65, 0);
        armL.rotation.z = 0.08;
        armL.castShadow = true;
        group.add(armL);
        // Right arm
        const armR = new THREE.Mesh(armGeo, armMat);
        armR.position.set(S * 0.65, S * 1.65, 0);
        armR.rotation.z = -0.08;
        armR.castShadow = true;
        group.add(armR);

        // Hands (small cylinders, yellow by default)
        const handGeo = new THREE.CylinderGeometry(S * 0.1, S * 0.1, S * 0.2, 8);
        const handMat = new THREE.MeshStandardMaterial({ color: 0xFFD500, roughness: 0.5 });
        const handL = new THREE.Mesh(handGeo, handMat);
        handL.position.set(-S * 0.65, S * 1.15, 0);
        group.add(handL);
        const handR = new THREE.Mesh(handGeo, handMat);
        handR.position.set(S * 0.65, S * 1.15, 0);
        group.add(handR);

        // -- HIPS/WAIST --
        const hipGeo = new THREE.BoxGeometry(S * 0.9, S * 0.15, S * 0.55);
        const hipMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(charDef.legs).multiplyScalar(0.9), roughness: 0.6 });
        const hip = new THREE.Mesh(hipGeo, hipMat);
        hip.position.set(0, S * 1.17, 0);
        hip.castShadow = true;
        group.add(hip);

        // -- LEGS --
        const legGeo = new THREE.BoxGeometry(S * 0.38, S * 0.95, S * 0.5);
        const legMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(charDef.legs), roughness: 0.6 });
        // Left leg
        const legL = new THREE.Mesh(legGeo, legMat);
        legL.position.set(-S * 0.22, S * 0.55, 0);
        legL.castShadow = true;
        group.add(legL);
        // Right leg
        const legR = new THREE.Mesh(legGeo, legMat);
        legR.position.set(S * 0.22, S * 0.55, 0);
        legR.castShadow = true;
        group.add(legR);

        // Feet (slightly wider)
        const footGeo = new THREE.BoxGeometry(S * 0.4, S * 0.12, S * 0.6);
        const footMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(charDef.legs).multiplyScalar(0.85), roughness: 0.7 });
        const footL = new THREE.Mesh(footGeo, footMat);
        footL.position.set(-S * 0.22, S * 0.06, S * 0.05);
        group.add(footL);
        const footR = new THREE.Mesh(footGeo, footMat);
        footR.position.set(S * 0.22, S * 0.06, S * 0.05);
        group.add(footR);

        // Name label (stored in userData for reference)
        group.userData.isMinifig = true;
        group.userData.charId = charDef.id;
        group.userData.charName = charDef.name;

        return group;
    }

    // Place selected minifig from gallery
    function placeSelectedMinifig() {
        if (!selectedMinifig) {
            showToast('Select a character first!', 'error');
            return;
        }
        const charDef = MINIFIG_CHARACTERS.find(c => c.id === selectedMinifig);
        if (!charDef) return;

        const gx = state.cursorX || 16;
        const gz = state.cursorZ || 16;
        const autoLayer = getStackHeight(gx, gz);
        const layer = state.manualLayerMode && state.buildHeight > 0 ? state.buildHeight : autoLayer;

        // Check collision before placing
        if (checkCollision(gx, gz, layer)) {
            showToast('Cannot place here ‚Äî space occupied!', 'error');
            return;
        }

        const minifig = createMinifigure3D(charDef);
        const posX = gx * UNIT + UNIT / 2;
        const posZ = gz * UNIT + UNIT / 2;
        const posY = layer * HEIGHT;
        minifig.position.set(posX, posY, posZ);
        // Apply rotation
        minifig.rotation.y = (state.rotation * Math.PI) / 180;

        const minifigId = Date.now();
        minifig.userData = {
            id: minifigId,
            gridX: gx,
            gridZ: gz,
            layer: layer,
            rotation: state.rotation,
            isMinifig: true,
            charId: charDef.id,
            color: charDef.torso
        };

        // Add to bricksGroup (same as bricks) so raycasting/selection/deletion works
        bricksGroup.add(minifig);

        const brickData = {
            id: minifigId,
            mesh: minifig,
            x: gx,
            y: gz,
            z: layer,
            type: 'minifig_' + charDef.id,
            color: charDef.torso,
            rotation: state.rotation,
            isMinifig: true,
            width: 1,
            depth: 1,
            height: 3
        };
        state.placedBricks.push(brickData);
        state.history.push({ action: 'add', brick: brickData });

        updateUI();
        showToast(`${charDef.icon} ${charDef.name} placed at (${gx}, ${gz}) layer ${layer}!`, 'success');
    }

    // Place custom minifig from color pickers
    function placeCustomMinifig() {
        const headColor = document.getElementById('minifig-head-color').value;
        const torsoColor = document.getElementById('minifig-torso-color').value;
        const legsColor = document.getElementById('minifig-legs-color').value;
        const armsColor = document.getElementById('minifig-arms-color').value;
        const hairSelect = document.getElementById('minifig-hair').value;

        const charDef = {
            id: 'custom_' + Date.now(),
            name: 'Custom Minifig',
            head: headColor,
            torso: torsoColor,
            legs: legsColor,
            arms: armsColor,
            headgear: hairSelect !== 'none' ? torsoColor : null,
            headgearType: hairSelect !== 'none' ? hairSelect : null,
            accent: null,
            icon: 'üßë'
        };

        const gx = state.cursorX || 16;
        const gz = state.cursorZ || 16;
        const autoLayer = getStackHeight(gx, gz);
        const layer = state.manualLayerMode && state.buildHeight > 0 ? state.buildHeight : autoLayer;

        if (checkCollision(gx, gz, layer)) {
            showToast('Cannot place here ‚Äî space occupied!', 'error');
            return;
        }

        const minifig = createMinifigure3D(charDef);
        const posX = gx * UNIT + UNIT / 2;
        const posZ = gz * UNIT + UNIT / 2;
        const posY = layer * HEIGHT;
        minifig.position.set(posX, posY, posZ);
        minifig.rotation.y = (state.rotation * Math.PI) / 180;

        const minifigId = Date.now();
        minifig.userData = {
            id: minifigId,
            gridX: gx,
            gridZ: gz,
            layer: layer,
            rotation: state.rotation,
            isMinifig: true,
            charId: 'custom',
            color: torsoColor
        };

        bricksGroup.add(minifig);

        const brickData = {
            id: minifigId,
            mesh: minifig,
            x: gx,
            y: gz,
            z: layer,
            type: 'minifig_custom',
            color: torsoColor,
            rotation: state.rotation,
            isMinifig: true,
            width: 1,
            depth: 1,
            height: 3
        };
        state.placedBricks.push(brickData);
        state.history.push({ action: 'add', brick: brickData });

        updateUI();
        showToast('üßë Custom Minifig placed!', 'success');
    }

    // Init minifig grid on load
    function initMinifigGrid() {
        renderMinifigGrid(MINIFIG_CHARACTERS);
    }

    // ========== TAB SWITCHING ==========
    function showPartsTab(tab) {
        document.querySelectorAll('#parts-tab-bar .tab-btn').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active');
        document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
        document.getElementById(`tab-${tab}`).classList.add('active');
    }

    // ========== ENHANCED KEYBOARD SHORTCUTS ==========
    const _origOnKeyDown = onKeyDown;
    onKeyDown = function(e) {
        _origOnKeyDown(e);
        if(e.key === 'm') toggleMirrorMode();
        if(e.key === 'p') takeScreenshot();
        if(e.key === '?') showHelp();
        if(e.key === 's' && e.ctrlKey) { e.preventDefault(); saveDesign(); }
    };

    // ========== AMS BAMBU PANEL ENHANCEMENT ==========
    const _origShowBambu = showBambuPanel;
    showBambuPanel = async function() {
        await _origShowBambu();

        // Also show AMS config
        if (state.placedBricks.length > 0) {
            const bricks = state.placedBricks.map(b => ({
                type: b.type, x: b.x, y: b.y, z: b.z, color: b.color,
            }));

            try {
                const res = await fetch('/api/export/ams', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bricks }),
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                const ams = data.ams_config;

                const amsHtml = `
                    <div style="margin-top:12px;border-top:1px solid var(--border);padding-top:10px;">
                        <strong style="color:var(--success);">üé® AMS Color Config:</strong><br>
                        ${ams.ams_slots.map(s => `
                            <div style="display:flex;align-items:center;gap:6px;margin:4px 0;font-size:0.8em;">
                                <span style="width:14px;height:14px;border-radius:3px;background:${s.hex};display:inline-block;border:1px solid #fff3;"></span>
                                Slot ${s.slot}: <strong>${s.color}</strong> (${s.brick_count} bricks)
                            </div>
                        `).join('')}
                        ${ams.needs_manual_swap ? `<div style="color:var(--warning);font-size:0.8em;margin-top:6px;">‚ö†Ô∏è ${ams.extra_colors.length} extra color(s) need manual swap</div>` : '<div style="color:var(--success);font-size:0.8em;margin-top:6px;">‚úÖ All colors fit in AMS!</div>'}
                    </div>
                `;
                document.getElementById('bambu-info').insertAdjacentHTML('beforeend', amsHtml);
            } catch(e) {
                console.error('AMS config failed:', e);
            }
        }
    };

    // ========== TURNTABLE ANIMATION ==========
    let turntableActive = false;
    let turntableSpeed = 0.5;

    function toggleTurntable() {
        turntableActive = !turntableActive;
        if(turntableActive) {
            showToast('üîÑ Turntable ON ‚Äî design is rotating', 'success');
        } else {
            showToast('üîÑ Turntable OFF');
        }
    }

    // Patch animate to include turntable
    const _origAnimate = animate;
    animate = function() {
        requestAnimationFrame(animate);
        controls.update();
        if(turntableActive) {
            bricksGroup.rotation.y += turntableSpeed * 0.01;
        }
        renderer.render(scene, camera);
    };

    // ========== DESIGN SHARING ==========
    async function shareDesign() {
        if(state.placedBricks.length === 0) {
            showToast('Nothing to share!', 'error');
            return;
        }
        const bricks = state.placedBricks.map(b => ({
            type: b.type, x: b.x, y: b.y, z: b.z, color: b.color, rotation: b.rotation || 0,
        }));
        const name = document.getElementById('design-name').value || 'My Design';

        try {
            const res = await fetch('/api/designs/share', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, bricks }),
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const shareUrl = window.location.origin + data.share_url;

            // Copy to clipboard
            try {
                await navigator.clipboard.writeText(shareUrl);
                showToast(`üìé Share link copied! ID: ${data.share_id}`, 'success');
            } catch(e) {
                showToast(`Share ID: ${data.share_id}`, 'success');
            }
        } catch(e) {
            console.error('Share failed:', e);
            showToast('Sharing unavailable ‚Äî API not connected', 'error');
        }
    }

    // ========== MULTI-SELECT ==========
    let multiSelectMode = false;
    let selectedBricks = new Set();

    function toggleMultiSelect() {
        multiSelectMode = !multiSelectMode;
        if(!multiSelectMode) {
            selectedBricks.clear();
        }
        showToast(multiSelectMode ? 'üî≤ Multi-select ON ‚Äî Shift+Click to select multiple' : 'üî≤ Multi-select OFF');
    }

    function deleteSelected() {
        if(selectedBricks.size === 0 && state.selectedPlacedBrick) {
            removeBrick(state.selectedPlacedBrick);
            return;
        }
        for(const id of selectedBricks) {
            removeBrick(id);
        }
        selectedBricks.clear();
        showToast('Deleted selected bricks', 'success');
    }

    // ========== QUICK STATS UPDATE ==========
    function updateQuickStats() {
        const el = document.getElementById('quick-stats');
        if(state.placedBricks.length === 0) {
            el.innerHTML = 'No bricks placed yet';
            return;
        }
        const colors = new Set(state.placedBricks.map(b => b.color));
        const types = new Set(state.placedBricks.map(b => b.type));
        el.innerHTML = `
            üß± ${state.placedBricks.length} bricks<br>
            üé® ${colors.size} colors<br>
            üì¶ ${types.size} types<br>
            ‚öñÔ∏è ~${(state.placedBricks.length * 2.3).toFixed(0)}g
        `;
    }

    // Patch updateUI to include quick stats and status bar
    const _origUpdateUI = updateUI;
    updateUI = function() {
        _origUpdateUI();
        updateQuickStats();
        const el = document.getElementById('total-bricks-status');
        if(el) el.textContent = state.placedBricks.length;
    };

    // ========== CUSTOM COLOR PICKER ==========
    function selectCustomColor(hex) {
        if(!hex.startsWith('#')) hex = '#' + hex;
        state.selectedColor = hex;
        state.selectedColorName = 'custom';
        document.getElementById('custom-color').value = hex;
        document.getElementById('hex-input').value = hex;
        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
        createGhostBrick();
        showToast(`Color: ${hex}`);
    }

    // ========== BRICK SEARCH ==========
    function filterBricks(query) {
        const items = document.querySelectorAll('#brick-palette .brick-item');
        const q = query.toLowerCase();
        items.forEach(item => {
            const name = item.querySelector('.brick-name').textContent.toLowerCase();
            item.style.display = !q || name.includes(q) ? '' : 'none';
        });
        // Also filter technic
        const technicItems = document.querySelectorAll('#technic-palette .brick-item');
        technicItems.forEach(item => {
            const name = item.querySelector('.brick-name').textContent.toLowerCase();
            item.style.display = !q || name.includes(q) ? '' : 'none';
        });
    }

    // ========== REDO ==========
    let redoStack = [];

    // Patch undo to push to redo stack
    const _origUndo = undoAction;
    undoAction = function() {
        const last = state.history[state.history.length - 1];
        if(last) {
            redoStack.push(last);
        }
        _origUndo();
    };

    function redoAction() {
        const last = redoStack.pop();
        if(!last) { showToast('Nothing to redo'); return; }
        if(last.action === 'add') {
            // Re-place the brick
            state.selectedBrick = last.brick.type;
            state.selectedColor = last.brick.mesh?.userData?.color || '#CC0000';
            state.selectedColorName = last.brick.color;
            state.buildHeight = last.brick.z;
            _origPlaceBrick(last.brick.x, last.brick.y);
        }
        showToast('Redone!');
    }

    // ========== ENHANCED KEYBOARD SHORTCUTS ==========
    // Re-patch with redo support
    const _origOnKeyDown2 = onKeyDown;
    onKeyDown = function(e) {
        _origOnKeyDown2(e);
        if(e.key === 'y' && e.ctrlKey) { e.preventDefault(); redoAction(); }
        if(e.key === 't') toggleTurntable();
    };

    // ========== GRID CUSTOMIZATION ==========
    function setGridSize(size) {
        scene.remove(gridHelper);
        gridHelper = new THREE.GridHelper(32 * UNIT, size, 0x005500, 0x004400);
        gridHelper.position.set(16 * UNIT, 0.15, 16 * UNIT);
        if (Array.isArray(gridHelper.material)) {
            gridHelper.material.forEach(m => { m.transparent = true; m.opacity = 0.4; m.depthWrite = false; });
        } else {
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.4;
            gridHelper.material.depthWrite = false;
        }
        scene.add(gridHelper);
        showToast(`Grid: ${size} divisions`);
    }

    // ========== COST ESTIMATOR ==========
    async function showCostEstimate() {
        if(state.placedBricks.length === 0) {
            showToast('Place some bricks first!', 'error');
            return;
        }
        const bricks = state.placedBricks.map(b => ({
            type: b.type, x: b.x, y: b.y, z: b.z, color: b.color,
        }));

        try {
            const res = await fetch('/api/tools/estimate-cost', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bricks, currency: 'jpy' }),
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const c = data.cost_estimate;

            const html = `
                <div class="modal-overlay" onclick="if(event.target===this)this.remove()">
                    <div class="modal">
                        <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">‚úï</button>
                        <h2>üí∞ Cost Estimate (${c.brick_count} bricks)</h2>

                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:16px;">
                            <div style="background:var(--bg);padding:14px;border-radius:10px;text-align:center;border:1px solid var(--warning);">
                                <div style="font-size:0.75em;color:var(--text2);">üß± LEGO Official</div>
                                <div style="font-size:1.4em;font-weight:700;color:var(--warning);">${c.lego_official.symbol}${c.lego_official.total.toLocaleString()}</div>
                                <div style="font-size:0.7em;color:var(--text2);">Per brick: ${c.lego_official.symbol}${c.lego_official.per_brick_avg}</div>
                            </div>
                            <div style="background:var(--bg);padding:14px;border-radius:10px;text-align:center;border:1px solid var(--accent);">
                                <div style="font-size:0.75em;color:var(--text2);">üõí BrickLink</div>
                                <div style="font-size:1.4em;font-weight:700;color:var(--accent);">${c.lego_official.symbol}${c.bricklink_estimate.total.toLocaleString()}</div>
                                <div style="font-size:0.7em;color:var(--text2);">${c.bricklink_estimate.note}</div>
                            </div>
                            <div style="background:var(--bg);padding:14px;border-radius:10px;text-align:center;border:1px solid var(--success);">
                                <div style="font-size:0.75em;color:var(--text2);">üñ®Ô∏è 3D Print</div>
                                <div style="font-size:1.4em;font-weight:700;color:var(--success);">${c.lego_official.symbol}${c['3d_print_estimate'].total.toLocaleString()}</div>
                                <div style="font-size:0.7em;color:var(--text2);">${c['3d_print_estimate'].filament_weight_g}g PLA</div>
                            </div>
                        </div>

                        <div style="background:linear-gradient(135deg,#0a2a1a,#1a2a1a);border:1px solid var(--success);border-radius:10px;padding:14px;text-align:center;">
                            <div style="font-size:0.85em;color:var(--success);">
                                üèÜ Cheapest: <strong>${c.cheapest_option}</strong>
                                ${c.savings_vs_lego > 0 ? `<br>Save ${c.lego_official.symbol}${c.savings_vs_lego.toLocaleString()} vs LEGO!` : ''}
                            </div>
                        </div>

                        <div style="margin-top:12px;font-size:0.75em;color:var(--text2);">
                            <em>* Prices are estimates. LEGO prices from Pick-a-Brick. BrickLink is marketplace average. 3D print based on PLA at ~¬•3,750/kg.</em>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', html);
        } catch(e) {
            console.error('Cost estimate failed:', e);
            showToast('Cost estimate unavailable ‚Äî API not connected', 'error');
        }
    }

    // ========== LDRAW IMPORT ==========
    function showImportDialog() {
        const html = `
            <div class="modal-overlay" onclick="if(event.target===this)this.remove()">
                <div class="modal">
                    <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">‚úï</button>
                    <h2>üì• Import Design</h2>

                    <div class="tab-bar">
                        <button class="tab-btn active" onclick="showImportTab('ldraw',this)">LDraw (.ldr)</button>
                        <button class="tab-btn" onclick="showImportTab('json',this)">JSON</button>
                        <button class="tab-btn" onclick="showImportTab('file',this)">File Upload</button>
                    </div>

                    <div id="import-ldraw">
                        <div class="prop-group">
                            <div class="prop-label">Paste LDraw content:</div>
                            <textarea class="prop-input" id="ldraw-input" rows="10"
                                placeholder="Paste LDraw (.ldr) content here...&#10;&#10;Example:&#10;1 4 0 0 0 1 0 0 0 1 0 0 0 1 3001.dat"
                                style="resize:vertical;font-family:monospace;font-size:0.78em;"></textarea>
                        </div>
                        <button class="btn btn-primary" onclick="importLDraw()" style="width:100%;">üì• Import LDraw</button>
                    </div>

                    <div id="import-json" style="display:none;">
                        <div class="prop-group">
                            <div class="prop-label">Paste design JSON:</div>
                            <textarea class="prop-input" id="json-input" rows="10"
                                placeholder='[{"type":"2x4","x":0,"y":0,"z":0,"color":"red"}]'
                                style="resize:vertical;font-family:monospace;font-size:0.78em;"></textarea>
                        </div>
                        <button class="btn btn-primary" onclick="importJSON()" style="width:100%;">üì• Import JSON</button>
                    </div>

                    <div id="import-file" style="display:none;">
                        <div class="prop-group">
                            <div class="prop-label">Upload a file:</div>
                            <input type="file" id="file-input" accept=".ldr,.json,.dat" class="prop-input"
                                   onchange="importFile(this.files[0])">
                        </div>
                        <div style="font-size:0.78em;color:var(--text2);margin-top:8px;">
                            Supported: .ldr (LDraw), .json (Design JSON), .dat (LDraw Part)
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', html);
    }

    function showImportTab(tab, btn) {
        ['ldraw', 'json', 'file'].forEach(t => {
            document.getElementById('import-' + t).style.display = t === tab ? 'block' : 'none';
        });
        btn.parentElement.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
    }

    async function importLDraw() {
        const content = document.getElementById('ldraw-input').value;
        if(!content.trim()) { showToast('Paste LDraw content first!', 'error'); return; }

        try {
            const res = await fetch('/api/import/ldraw', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content }),
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();

            if(data.imported && data.imported.bricks.length > 0) {
                clearSceneSilent();
                for(const brick of data.imported.bricks) {
                    state.selectedBrick = brick.type;
                    state.selectedColor = window.colorData[brick.color] || '#CC0000';
                    state.selectedColorName = brick.color;
                    state.buildHeight = brick.z || 0;
                    _origPlaceBrick(brick.x || 0, brick.y || 0);
                }
                state.selectedBrick = '2x4';
                state.selectedColor = '#CC0000';
                state.selectedColorName = 'red';
                state.buildHeight = 0;
                createGhostBrick();
                document.querySelector('.modal-overlay').remove();
                showToast(`Imported ${data.imported.brick_count} bricks from LDraw!`, 'success');
            } else {
                showToast('No bricks found in LDraw content', 'error');
            }
        } catch(e) {
            console.error('LDraw import failed:', e);
            showToast('LDraw import unavailable ‚Äî API not connected', 'error');
        }
    }

    function importJSON() {
        const content = document.getElementById('json-input').value;
        try {
            const bricks = JSON.parse(content);
            if(!Array.isArray(bricks)) { showToast('JSON must be an array of bricks', 'error'); return; }

            clearSceneSilent();
            for(const brick of bricks) {
                state.selectedBrick = brick.type || '2x4';
                state.selectedColor = window.colorData[brick.color] || '#CC0000';
                state.selectedColorName = brick.color || 'red';
                state.buildHeight = brick.z || 0;
                _origPlaceBrick(brick.x || 0, brick.y || 0);
            }
            state.selectedBrick = '2x4';
            state.selectedColor = '#CC0000';
            state.selectedColorName = 'red';
            state.buildHeight = 0;
            createGhostBrick();
            document.querySelector('.modal-overlay').remove();
            showToast(`Imported ${bricks.length} bricks from JSON!`, 'success');
        } catch(e) {
            showToast('Invalid JSON: ' + e.message, 'error');
        }
    }

    async function importFile(file) {
        if(!file) return;
        const content = await file.text();
        if(file.name.endsWith('.ldr') || file.name.endsWith('.dat')) {
            document.getElementById('ldraw-input').value = content;
            await importLDraw();
        } else if(file.name.endsWith('.json')) {
            document.getElementById('json-input').value = content;
            importJSON();
        } else {
            showToast('Unsupported file format', 'error');
        }
    }

    // ========== üñ®Ô∏è PRINTER HUB ==========
    async function showPrinterHub() {
        let printers, materials, refs, buyTimes;
        try {
            const [printerRes, matRes, refRes, buyRes] = await Promise.all([
                fetch('/api/printers/list').then(r => { if(!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); }),
                fetch('/api/printers/materials').then(r => { if(!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); }),
                fetch('/api/printers/references').then(r => { if(!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); }),
                fetch('/api/printers/best-time-to-buy').then(r => { if(!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); }),
            ]);

            printers = printerRes.printers || [];
            materials = matRes.materials || {};
            refs = refRes.references || {};
            buyTimes = buyRes.best_times || {};
        } catch(e) {
            console.error('Printer hub failed:', e);
            showToast('Printer hub unavailable ‚Äî API not connected', 'error');
            return;
        }

        let html = `<div class="modal-overlay" onclick="if(event.target===this)this.remove()">
        <div class="modal" style="max-width:900px;max-height:85vh;overflow:auto;">
            <h2 style="margin-bottom:16px;">üñ®Ô∏è 3D Printer Hub ‚Äî Complete Reference</h2>

            <h3>üè™ Printer Comparison (${printers.length} printers)</h3>
            <table style="width:100%;border-collapse:collapse;font-size:0.82em;margin-bottom:20px;">
            <tr style="background:var(--bg3);"><th style="padding:8px;text-align:left;">Model</th><th>Price</th><th>Bed Size</th><th>Speed</th><th>Multi-Color</th><th>Rating</th><th>Best For</th></tr>
            ${printers.map(p => `<tr style="border-bottom:1px solid var(--border);">
                <td style="padding:8px;"><strong>${p.brand} ${p.model}</strong><br><a href="${p.url}" target="_blank" style="color:var(--accent);font-size:0.85em;">Visit Site ‚Üí</a></td>
                <td style="padding:8px;font-weight:700;color:var(--success);">$${p.price_usd}</td>
                <td style="padding:8px;">${p.bed_size ? p.bed_size.join('√ó')+'mm' : 'N/A'}</td>
                <td style="padding:8px;">${p.max_speed ? p.max_speed+'mm/s' : 'Resin'}</td>
                <td style="padding:8px;">${p.multi_color ? '‚úÖ' : '‚ùå'}</td>
                <td style="padding:8px;">‚≠ê${p.rating}</td>
                <td style="padding:8px;font-size:0.85em;color:var(--text2);">${p.best_for || ''}</td>
            </tr>`).join('')}
            </table>

            <h3>üß™ Materials for LEGO Printing</h3>
            <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:10px;margin-bottom:20px;">
            ${Object.entries(materials).map(([k,m]) => `<div style="background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:12px;">
                <div style="font-weight:700;">${m.icon || 'üßµ'} ${m.name}</div>
                <div style="font-size:0.8em;color:var(--text2);margin:4px 0;">${m.best_for || ''}</div>
                <div style="font-size:0.78em;">üí™ Strength: ${m.strength || 'N/A'} | üìê Detail: ${m.detail || 'N/A'}</div>
                <div style="font-size:0.78em;">üí∞ ~$${m.price_per_kg || '?'}/kg</div>
                <div style="font-size:0.78em;color:var(--success);margin-top:4px;">üß± ${m.lego_compatibility || ''}</div>
            </div>`).join('')}
            </div>

            <h3>üè∑Ô∏è Best Time to Buy</h3>
            <div style="margin-bottom:20px;">
            ${Object.entries(buyTimes).filter(([k]) => k !== 'general_tips').map(([brand, info]) => `
                <div style="margin-bottom:12px;"><strong>${brand.replace('_',' ').toUpperCase()}</strong>
                ${(info.best_times || []).map(t => `<div style="font-size:0.82em;padding:4px 0;">${t.icon} <strong>${t.event}</strong> ‚Äî ${t.month} ‚Äî <span style="color:var(--success);">${t.discount}</span></div>`).join('')}
                </div>`).join('')}
            <div style="background:var(--bg3);border-radius:10px;padding:12px;margin-top:8px;">
                <strong>üí° General Tips:</strong>
                ${(buyTimes.general_tips || []).map(t => `<div style="font-size:0.82em;padding:2px 0;">${t}</div>`).join('')}
            </div>
            </div>

            <h3>üåê Reference Sites</h3>
            ${Object.entries(refs).map(([category, sites]) => `
                <div style="margin-bottom:12px;">
                <strong style="text-transform:capitalize;">${category.replace('_', ' ')}</strong>
                <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:6px;margin-top:6px;">
                ${sites.map(s => `<a href="${s.url}" target="_blank" style="background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:8px;text-decoration:none;color:var(--text);display:block;">
                    <div style="font-weight:600;">${s.icon || 'üîó'} ${s.name}</div>
                    <div style="font-size:0.78em;color:var(--text2);">${s.description}</div>
                </a>`).join('')}
                </div></div>`).join('')}

            <div style="text-align:right;margin-top:16px;"><button class="btn btn-primary" onclick="this.closest('.modal-overlay').remove()">Close</button></div>
        </div></div>`;

        document.body.insertAdjacentHTML('beforeend', html);
    }

    // ========== ü§ñ AI DESIGN ASSISTANT ==========
    async function showAIAssistant() {
        let challenge = {};
        try {
            const challengeRes = await fetch('/api/amazing/ai/random');
            if (!challengeRes.ok) throw new Error(`HTTP ${challengeRes.status}`);
            const challengeData = await challengeRes.json();
            challenge = challengeData.challenge || {};
        } catch(e) {
            console.log('AI challenge API unavailable:', e.message);
            challenge = { theme: 'üéØ', challenge: 'API unavailable', difficulty: 'N/A' };
        }

        let html = `<div class="modal-overlay" onclick="if(event.target===this)this.remove()">
        <div class="modal" style="max-width:600px;">
            <h2>ü§ñ AI Design Assistant</h2>
            <p style="color:var(--text2);margin:8px 0;">Describe what you want to build and I'll suggest designs!</p>

            <div style="margin:16px 0;">
                <input type="text" class="prop-input" id="ai-idea-input" placeholder="e.g., a castle with dragons, a Japanese temple, a race car..."
                       style="font-size:1em;padding:12px;" onkeydown="if(event.key==='Enter')aiSuggest()">
                <div style="display:flex;gap:8px;margin-top:8px;">
                    <select class="prop-input" id="ai-difficulty" style="flex:1;">
                        <option value="any">Any Difficulty</option>
                        <option value="easy">Easy</option>
                        <option value="medium">Medium</option>
                        <option value="hard">Hard</option>
                    </select>
                    <button class="btn btn-primary" onclick="aiSuggest()" style="flex:1;">üîç Get Suggestions</button>
                </div>
            </div>

            <div style="background:var(--bg3);border-radius:10px;padding:12px;margin-bottom:16px;">
                <div style="font-weight:700;">${challenge.theme || 'üéØ'} Daily Challenge!</div>
                <div style="margin:4px 0;">${challenge.challenge || ''}</div>
                <div style="font-size:0.82em;color:var(--accent);">Difficulty: ${challenge.difficulty || 'Medium'}</div>
            </div>

            <div id="ai-suggestions" style="min-height:100px;"></div>

            <div style="text-align:right;margin-top:16px;"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Close</button></div>
        </div></div>`;
        document.body.insertAdjacentHTML('beforeend', html);
    }

    async function aiSuggest() {
        const idea = document.getElementById('ai-idea-input').value;
        const difficulty = document.getElementById('ai-difficulty').value;
        if(!idea) { showToast('Enter an idea first!', 'warning'); return; }

        try {
            const res = await fetch('/api/amazing/ai/suggest', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ idea, difficulty })
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const suggestions = data.suggestions || [];

            const container = document.getElementById('ai-suggestions');
            container.innerHTML = `<div style="font-weight:700;margin-bottom:8px;">üí° Suggestions for "${idea}":</div>` +
                suggestions.map(s => `<div style="background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:6px;cursor:pointer;" onclick="loadAIPreset('${s.id}')">
                    <div style="font-weight:600;">${s.name} <span style="font-size:0.8em;color:var(--accent);">(${s.difficulty})</span></div>
                    <div style="font-size:0.82em;color:var(--text2);">${s.description}</div>
                    <div style="font-size:0.78em;color:var(--text2);">üß± ~${s.bricks} bricks | Score: ${s.score}</div>
                </div>`).join('');
        } catch(e) {
            console.error('AI suggest failed:', e);
            showToast('AI suggestions unavailable ‚Äî API not connected', 'error');
        }
    }

    async function loadAIPreset(presetId) {
        try {
            const res = await fetch(`/api/presets/${presetId}`);
            if(res.ok) {
                const data = await res.json();
                if(data.design && data.design.bricks) {
                    clearSceneSilent();
                    for(const brick of data.design.bricks) {
                        state.selectedBrick = brick.type || '2x4';
                        state.selectedColor = window.colorData[brick.color] || '#CC0000';
                        state.selectedColorName = brick.color || 'red';
                        state.buildHeight = brick.z || 0;
                        _origPlaceBrick(brick.x || 0, brick.y || 0);
                    }
                    state.buildHeight = 0; createGhostBrick();
                    document.querySelector('.modal-overlay')?.remove();
                    showToast(`Loaded "${presetId}" preset!`, 'success');
                }
            } else {
                showToast(`Preset "${presetId}" not available as buildable model yet`, 'info');
            }
        } catch(e) { showToast('Could not load preset', 'error'); }
    }

    // ========== üé¨ BUILD ANIMATION ==========
    async function playBuildAnimation() {
        const bricksData = state.bricks.map((m, i) => ({
            type: m.userData?.brickType || '2x4',
            x: Math.round(m.position.x), y: Math.round(m.position.z),
            z: Math.round(m.position.y), color: m.userData?.colorName || 'red',
        }));

        if(bricksData.length === 0) { showToast('No bricks to animate!', 'warning'); return; }

        try {
            const res = await fetch('/api/amazing/animation/generate', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ bricks: bricksData, speed: 0.5, style: 'bottom_up' })
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const keyframes = data.animation?.keyframes || [];

            showToast(`üé¨ Playing build animation (${keyframes.length} steps)...`, 'success');

            // Hide all bricks first
            state.bricks.forEach(m => { m.visible = false; });

            // Animate bricks appearing one by one
            for(let i = 0; i < state.bricks.length && i < keyframes.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 400));
                state.bricks[i].visible = true;
                state.bricks[i].scale.set(0.01, 0.01, 0.01);

                // Animate scale up with bounce
                const brick = state.bricks[i];
                let t = 0;
                const animInterval = setInterval(() => {
                    t += 0.05;
                    if(t >= 1) { brick.scale.set(1,1,1); clearInterval(animInterval); return; }
                    const bounce = 1 + Math.sin(t * Math.PI) * 0.3 * (1 - t);
                    brick.scale.set(bounce, bounce, bounce);
                }, 16);
            }

            showToast('üé¨ Animation complete!', 'success');
        } catch(e) {
            console.error('Build animation failed:', e);
            showToast('Build animation unavailable ‚Äî API not connected', 'error');
        }
    }

    // ========== üèóÔ∏è STRUCTURAL CHECK ==========
    async function checkStructure() {
        const bricksData = state.bricks.map(m => ({
            type: m.userData?.brickType || '2x4',
            x: Math.round(m.position.x), y: Math.round(m.position.z),
            z: Math.round(m.position.y), color: m.userData?.colorName || 'red',
        }));

        if(bricksData.length === 0) { showToast('No bricks to check!', 'warning'); return; }

        try {
            const res = await fetch('/api/amazing/physics/check', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ bricks: bricksData })
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const analysis = data.structural_analysis || {};

            const gradeColors = { A: '#10b981', B: '#22c55e', C: '#f59e0b', D: '#ef4444', F: '#dc2626' };

            let html = `<div class="modal-overlay" onclick="if(event.target===this)this.remove()">
            <div class="modal" style="max-width:500px;">
                <h2>üèóÔ∏è Structural Analysis</h2>
                <div style="text-align:center;margin:20px 0;">
                    <div style="font-size:4em;font-weight:900;color:${gradeColors[analysis.grade] || '#888'};">${analysis.grade || '?'}</div>
                    <div style="font-size:1.2em;color:var(--text2);">Score: ${analysis.score}/100</div>
                    <div style="font-size:0.9em;color:var(--text2);">Printability: ${analysis.printability}</div>
                </div>
                ${(analysis.issues || []).map(i => `<div style="background:#2a1a1a;border:1px solid var(--danger);border-radius:8px;padding:10px;margin-bottom:6px;">
                    <div style="font-weight:700;color:var(--danger);">‚ö†Ô∏è ${i.message}</div>
                    <div style="font-size:0.82em;color:var(--text2);">üí° Fix: ${i.fix}</div>
                </div>`).join('')}
                ${(analysis.warnings || []).map(w => `<div style="background:#2a2a1a;border:1px solid var(--warning);border-radius:8px;padding:10px;margin-bottom:6px;">
                    <div style="font-weight:600;color:var(--warning);">‚ö° ${w.message}</div>
                    <div style="font-size:0.82em;color:var(--text2);">üí° Fix: ${w.fix}</div>
                </div>`).join('')}
                <div style="background:var(--bg3);border-radius:8px;padding:10px;margin-top:10px;font-size:0.85em;">
                    <div>üß± Total Bricks: ${analysis.stats?.total_bricks || 0}</div>
                    <div>üèóÔ∏è Max Height: ${analysis.stats?.max_height || 0} layers</div>
                    <div>‚ö° Floating: ${analysis.stats?.floating_bricks || 0}</div>
                    <div>üìê Overhangs: ${analysis.stats?.overhang_count || 0}</div>
                </div>
                <div style="text-align:right;margin-top:16px;"><button class="btn btn-primary" onclick="this.closest('.modal-overlay').remove()">Close</button></div>
            </div></div>`;
            document.body.insertAdjacentHTML('beforeend', html);
        } catch(e) {
            console.error('Structural check failed:', e);
            showToast('Structural check unavailable ‚Äî API not connected', 'error');
        }
    }

    // ========== üåç COMMUNITY DESIGNS ==========
    async function showCommunity() {
        try {
            const communityRes = await fetch('/api/amazing/community/popular');
            if (!communityRes.ok) throw new Error(`HTTP ${communityRes.status}`);
            const res = await communityRes.json();
            const designs = res.designs || [];

            let html = `<div class="modal-overlay" onclick="if(event.target===this)this.remove()">
            <div class="modal" style="max-width:700px;max-height:80vh;overflow:auto;">
                <h2>üåç Community Designs</h2>
                <p style="color:var(--text2);margin-bottom:16px;">Popular LEGO-compatible designs from around the world</p>
                <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:10px;">
                ${designs.map(d => `<a href="${d.url}" target="_blank" style="background:var(--bg3);border:1px solid var(--border);border-radius:10px;padding:14px;text-decoration:none;color:var(--text);">
                    <div style="font-weight:700;font-size:1.05em;">${d.name}</div>
                    <div style="font-size:0.82em;color:var(--text2);">by ${d.author} ‚Ä¢ ${d.source}</div>
                    <div style="display:flex;gap:12px;margin-top:6px;font-size:0.82em;">
                        <span>‚ù§Ô∏è ${d.likes.toLocaleString()}</span>
                        <span>üì• ${d.downloads.toLocaleString()}</span>
                        <span style="color:var(--accent);">${d.difficulty}</span>
                    </div>
                </a>`).join('')}
                </div>
                <div style="text-align:right;margin-top:16px;"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Close</button></div>
            </div></div>`;
            document.body.insertAdjacentHTML('beforeend', html);
        } catch(e) {
            console.error('Community designs failed:', e);
            showToast('Community designs unavailable ‚Äî API not connected', 'error');
        }
    }

    // ========== üè¢ MULTI-FLOOR BUILDING GENERATOR ==========
    async function generateBuilding() {
        let html = `<div class="modal-overlay" onclick="if(event.target===this)this.remove()">
        <div class="modal" style="max-width:450px;">
            <h2>üè¢ Building Generator</h2>
            <p style="color:var(--text2);margin-bottom:12px;">Auto-generate multi-floor buildings</p>
            <div class="prop-group"><div class="prop-label">Floors</div>
                <input type="range" class="prop-input" id="gen-floors" min="1" max="10" value="3" oninput="document.getElementById('gen-floors-val').textContent=this.value">
                <span id="gen-floors-val" style="font-size:0.8em;">3</span></div>
            <div class="prop-group"><div class="prop-label">Width (studs)</div>
                <input type="range" class="prop-input" id="gen-width" min="4" max="20" value="8" oninput="document.getElementById('gen-width-val').textContent=this.value">
                <span id="gen-width-val" style="font-size:0.8em;">8</span></div>
            <div class="prop-group"><div class="prop-label">Depth (studs)</div>
                <input type="range" class="prop-input" id="gen-depth" min="4" max="20" value="8" oninput="document.getElementById('gen-depth-val').textContent=this.value">
                <span id="gen-depth-val" style="font-size:0.8em;">8</span></div>
            <div class="prop-group"><div class="prop-label">Style</div>
                <select class="prop-input" id="gen-style">
                    <option value="modern">üèôÔ∏è Modern</option>
                    <option value="classic">üè† Classic</option>
                    <option value="japanese">üèØ Japanese</option>
                    <option value="industrial">üè≠ Industrial</option>
                </select></div>
            <div class="prop-group"><label><input type="checkbox" id="gen-interior" checked> Include interior furniture</label></div>
            <button class="btn btn-primary" onclick="doGenerateBuilding()" style="width:100%;margin-top:12px;">üèóÔ∏è Generate Building</button>
            <div style="text-align:right;margin-top:8px;"><button class="btn btn-sm" onclick="this.closest('.modal-overlay').remove()">Cancel</button></div>
        </div></div>`;
        document.body.insertAdjacentHTML('beforeend', html);
    }

    async function doGenerateBuilding() {
        const floors = parseInt(document.getElementById('gen-floors').value);
        const width = parseInt(document.getElementById('gen-width').value);
        const depth = parseInt(document.getElementById('gen-depth').value);
        const style = document.getElementById('gen-style').value;
        const interior = document.getElementById('gen-interior').checked;

        try {
            const res = await fetch('/api/amazing/building/floors', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ floors, width, depth, style, include_interior: interior })
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const building = data.building || {};

            if(building.bricks) {
                clearSceneSilent();
                for(const brick of building.bricks) {
                    state.selectedBrick = brick.type || '2x4';
                    state.selectedColor = window.colorData[brick.color] || '#CC0000';
                    state.selectedColorName = brick.color || 'red';
                    state.buildHeight = brick.z || 0;
                    _origPlaceBrick(brick.x || 0, brick.y || 0);
                }
                state.buildHeight = 0; createGhostBrick();
                document.querySelector('.modal-overlay')?.remove();
                showToast(`üè¢ Generated ${floors}-floor ${style} building (${building.brick_count} bricks)!`, 'success');
            }
        } catch(e) {
            console.error('Building generation failed:', e);
            showToast('Building generator unavailable ‚Äî API not connected', 'error');
        }
    }

    // ========== üé≠ DECALS & TEXTURES ==========
    async function showDecals() {
        try {
            const decalRes = await fetch('/api/amazing/decals');
            if (!decalRes.ok) throw new Error(`HTTP ${decalRes.status}`);
            const res = await decalRes.json();
            const decals = res.decals || {};
            const textures = res.textures || {};

            let html = `<div class="modal-overlay" onclick="if(event.target===this)this.remove()">
            <div class="modal" style="max-width:600px;max-height:80vh;overflow:auto;">
                <h2>üé≠ Decals & Textures</h2>
                <h3>üñºÔ∏è Decals</h3>
                ${Object.entries(decals).map(([cat, items]) => `
                    <div style="margin-bottom:12px;">
                    <div style="font-weight:600;text-transform:capitalize;margin-bottom:6px;">${cat}</div>
                    <div style="display:flex;flex-wrap:wrap;gap:6px;">
                    ${items.map(d => `<button class="btn btn-sm" onclick="applyDecal('${d.id}','${cat}')" title="${d.name}">${d.emoji || 'üìå'} ${d.name}</button>`).join('')}
                    </div></div>`).join('')}

                <h3 style="margin-top:16px;">‚ú® Textures</h3>
                <div style="display:flex;flex-wrap:wrap;gap:6px;">
                ${Object.entries(textures).map(([k,t]) => `<button class="btn btn-sm" onclick="applyTexture('${k}')" title="${t.name}">${t.icon || 'üé®'} ${t.name}</button>`).join('')}
                </div>

                <div style="text-align:right;margin-top:16px;"><button class="btn" onclick="this.closest('.modal-overlay').remove()">Close</button></div>
            </div></div>`;
            document.body.insertAdjacentHTML('beforeend', html);
        } catch(e) {
            console.error('Decals failed:', e);
            showToast('Decals unavailable ‚Äî API not connected', 'error');
        }
    }

    function applyDecal(decalId, category) {
        showToast(`Applied ${decalId} decal! (Select a brick face to apply)`, 'success');
    }

    function applyTexture(textureId) {
        showToast(`Applied ${textureId} texture to all bricks!`, 'success');
    }

    // ========== üìï INSTRUCTION BOOKLET ==========
    async function generateInstructionBook() {
        const bricksData = state.bricks.map(m => ({
            type: m.userData?.brickType || '2x4',
            x: Math.round(m.position.x), y: Math.round(m.position.z),
            z: Math.round(m.position.y), color: m.userData?.colorName || 'red',
        }));

        if(bricksData.length === 0) { showToast('No bricks ‚Äî build something first!', 'warning'); return; }

        const designName = document.getElementById('design-name')?.value || 'My Design';

        try {
            const res = await fetch('/api/amazing/instructions/pdf-data', {
                method: 'POST', headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ bricks: bricksData, name: designName, author: 'Dr. Imokawa' })
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const booklet = data.instruction_booklet || {};
            const pages = booklet.pages || [];

            let html = `<div class="modal-overlay" onclick="if(event.target===this)this.remove()">
            <div class="modal" style="max-width:700px;max-height:85vh;overflow:auto;">
                <h2>üìï Building Instructions</h2>
                <div style="text-align:center;margin-bottom:20px;">Like real LEGO instruction booklets!</div>`;

            for(const page of pages) {
                if(page.type === 'cover') {
                    html += `<div style="background:linear-gradient(135deg,var(--accent),var(--accent2));border-radius:12px;padding:30px;text-align:center;margin-bottom:16px;">
                        <div style="font-size:2em;font-weight:900;color:white;">üß± ${page.title}</div>
                        <div style="color:rgba(255,255,255,0.8);margin:8px 0;">by ${page.author}</div>
                        <div style="color:rgba(255,255,255,0.7);font-size:0.9em;">${page.brick_count} bricks ‚Ä¢ ${page.difficulty} ‚Ä¢ ~${page.estimated_time}</div>
                    </div>`;
                } else if(page.type === 'parts_list') {
                    html += `<div style="background:var(--bg3);border-radius:10px;padding:16px;margin-bottom:12px;">
                        <h3>üì¶ Parts List (${page.total_parts} pieces)</h3>
                        <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:8px;">
                        ${(page.parts || []).map(p => `<span style="background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:4px 8px;font-size:0.82em;">${p.count}√ó ${p.type} (${p.color})</span>`).join('')}
                        </div></div>`;
                } else if(page.type === 'step') {
                    const pct = page.progress_percent || 0;
                    html += `<div style="background:var(--bg3);border-radius:10px;padding:12px;margin-bottom:8px;">
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <strong>Step ${page.step_number}</strong>
                            <span style="font-size:0.82em;color:var(--text2);">${pct}%</span>
                        </div>
                        <div style="background:var(--bg);border-radius:4px;height:4px;margin:6px 0;">
                            <div style="background:var(--accent);border-radius:4px;height:4px;width:${pct}%;"></div>
                        </div>
                        <div style="font-size:0.85em;">${page.instruction}</div>
                        <div style="font-size:0.78em;color:var(--text2);">Add ${page.new_brick_count} brick(s) ‚Ä¢ Total so far: ${page.cumulative_count}</div>
                    </div>`;
                } else if(page.type === 'completion') {
                    html += `<div style="background:linear-gradient(135deg,#1a2e1a,#1a3e1a);border:1px solid var(--success);border-radius:12px;padding:24px;text-align:center;margin-top:12px;">
                        <div style="font-size:2em;">üéâ</div>
                        <div style="font-size:1.2em;font-weight:700;color:var(--success);">${page.message}</div>
                    </div>`;
                }
            }

            html += `<div style="text-align:right;margin-top:16px;"><button class="btn btn-primary" onclick="this.closest('.modal-overlay').remove()">Close</button></div>
            </div></div>`;
            document.body.insertAdjacentHTML('beforeend', html);
        } catch(e) {
            console.error('Instruction booklet failed:', e);
            showToast('Instruction booklet unavailable ‚Äî API not connected', 'error');
        }
    }

    // ========== iPad TOUCH SUPPORT ==========
    let isTouchDevice = false;
    let touchMode = 'place'; // 'place', 'delete', 'select', 'orbit'
    let longPressTimer = null;
    let longPressTriggered = false;
    let touchStartPos = { x: 0, y: 0 };
    let lastTouchPos = { x: 0, y: 0 };
    let pinchStartDist = 0;
    let pinchStartZoom = 0;
    let isTwoFingerGesture = false;
    let twoFingerStartAngle = 0;
    let longPressIndicator = null;

    function detectTouchDevice() {
        isTouchDevice = ('ontouchstart' in window) ||
                        (navigator.maxTouchPoints > 0) ||
                        (navigator.msMaxTouchPoints > 0) ||
                        (window.matchMedia('(pointer: coarse)').matches);
        return isTouchDevice;
    }

    function initTouchSupport() {
        if (!detectTouchDevice()) return;

        const canvas = document.getElementById('canvas3d');

        // Prevent default touch behaviors on canvas (no scroll/zoom)
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', onTouchCancel, { passive: false });

        // Show touch UI elements
        document.getElementById('touch-toolbar').style.display = 'flex';
        document.getElementById('touch-mode-indicator').style.display = 'block';
        document.getElementById('panel-toggle-bar').style.display = 'flex';

        // Set initial touch mode
        setTouchMode('place');

        // Disable double-tap-to-zoom on the entire app
        document.body.style.touchAction = 'manipulation';

        // Prevent iOS rubber-banding on the viewport
        document.querySelector('.viewport').style.touchAction = 'none';
        document.querySelector('.viewport').style.overscrollBehavior = 'none';

        console.log('‚úÖ iPad touch support initialized');
    }

    function setTouchMode(mode) {
        touchMode = mode;
        // Update button highlights
        document.querySelectorAll('.touch-btn').forEach(btn => btn.classList.remove('active'));
        const modeMap = {
            'place': 'touch-place-btn',
            'delete': 'touch-delete-btn',
            'select': 'touch-select-btn'
        };
        if (modeMap[mode]) {
            const el = document.getElementById(modeMap[mode]);
            if (el) el.classList.add('active');
        }
        // Update indicator
        const modeNames = {
            'place': 'Place Brick',
            'delete': 'Delete Brick',
            'select': 'Select Brick',
            'orbit': 'Orbit Camera'
        };
        const indicator = document.getElementById('touch-mode-text');
        if (indicator) indicator.textContent = modeNames[mode] || mode;
    }

    function touchAction(action) {
        switch (action) {
            case 'place':
                setTouchMode('place');
                showToast('‚úã Tap on baseplate to place brick');
                break;
            case 'delete':
                setTouchMode('delete');
                showToast('‚úã Tap a brick to delete it');
                break;
            case 'select':
                setTouchMode('select');
                showToast('‚úã Tap a brick to select it');
                break;
            case 'rotate':
                state.rotation = (state.rotation + 90) % 360;
                createGhostBrick();
                showToast(`üîÑ Rotation: ${state.rotation}¬∞`);
                break;
            case 'layerUp':
                state.buildHeight = Math.min(20, state.buildHeight + 1);
                document.getElementById('build-height').value = state.buildHeight;
                document.getElementById('height-display').textContent = state.buildHeight;
                createGhostBrick();
                showToast(`‚¨ÜÔ∏è Layer: ${state.buildHeight}`);
                break;
            case 'layerDown':
                state.buildHeight = Math.max(0, state.buildHeight - 1);
                document.getElementById('build-height').value = state.buildHeight;
                document.getElementById('height-display').textContent = state.buildHeight;
                createGhostBrick();
                showToast(`‚¨áÔ∏è Layer: ${state.buildHeight}`);
                break;
            case 'undo':
                undoAction();
                break;
            case 'save':
                saveDesign();
                break;
            case 'camera':
                resetCamera();
                showToast('üì∑ Camera reset');
                break;
        }
    }

    // ========== TOUCH EVENT HANDLERS ==========
    function onTouchStart(e) {
        e.preventDefault();

        if (e.touches.length === 2) {
            // Two-finger gesture: pinch-zoom or orbit
            isTwoFingerGesture = true;
            longPressTriggered = false;
            clearLongPress();

            const t1 = e.touches[0];
            const t2 = e.touches[1];
            pinchStartDist = getTouchDistance(t1, t2);
            pinchStartZoom = camera.position.distanceTo(controls.target);
            twoFingerStartAngle = getTouchAngle(t1, t2);
            return;
        }

        if (e.touches.length === 1) {
            isTwoFingerGesture = false;
            const touch = e.touches[0];
            touchStartPos = { x: touch.clientX, y: touch.clientY };
            lastTouchPos = { x: touch.clientX, y: touch.clientY };
            longPressTriggered = false;

            // Update mouse position for raycasting
            updateMouseFromTouch(touch);

            // Update ghost brick position
            updateGhostFromTouch();

            // Start long-press timer (for delete in place mode)
            if (touchMode === 'place') {
                startLongPress(touch);
            }
        }
    }

    function onTouchMove(e) {
        e.preventDefault();

        if (e.touches.length === 2 && isTwoFingerGesture) {
            // Pinch-to-zoom
            const t1 = e.touches[0];
            const t2 = e.touches[1];
            const currentDist = getTouchDistance(t1, t2);
            const scale = pinchStartDist / currentDist;
            const newDist = Math.max(20, Math.min(300, pinchStartZoom * scale));

            const direction = new THREE.Vector3()
                .subVectors(camera.position, controls.target)
                .normalize();
            camera.position.copy(controls.target).addScaledVector(direction, newDist);

            // Two-finger rotation
            const currentAngle = getTouchAngle(t1, t2);
            const angleDelta = currentAngle - twoFingerStartAngle;
            // Let OrbitControls handle the rotation naturally
            return;
        }

        if (e.touches.length === 1 && !isTwoFingerGesture) {
            const touch = e.touches[0];
            const dx = touch.clientX - touchStartPos.x;
            const dy = touch.clientY - touchStartPos.y;
            const moveDistance = Math.sqrt(dx * dx + dy * dy);

            // If moved significantly, cancel long-press and treat as orbit
            if (moveDistance > 15) {
                clearLongPress();
                longPressTriggered = false;

                // Orbit camera (let OrbitControls handle it naturally)
                // OrbitControls already listens to touch events on the renderer
            }

            lastTouchPos = { x: touch.clientX, y: touch.clientY };

            // Update ghost brick position
            updateMouseFromTouch(touch);
            updateGhostFromTouch();
        }
    }

    function onTouchEnd(e) {
        clearLongPress();

        if (isTwoFingerGesture) {
            if (e.touches.length === 0) {
                isTwoFingerGesture = false;
            }
            return;
        }

        if (longPressTriggered) {
            longPressTriggered = false;
            return;
        }

        // Single tap ‚Äî check if it was a tap (not a drag)
        if (e.changedTouches.length === 1) {
            const touch = e.changedTouches[0];
            const dx = touch.clientX - touchStartPos.x;
            const dy = touch.clientY - touchStartPos.y;
            const moveDistance = Math.sqrt(dx * dx + dy * dy);

            if (moveDistance < 15) {
                // This is a TAP
                updateMouseFromTouch(touch);
                handleTap();
            }
        }
    }

    function onTouchCancel(e) {
        clearLongPress();
        isTwoFingerGesture = false;
        longPressTriggered = false;
        removeLongPressIndicator();
    }

    // ========== TOUCH HELPERS ==========
    function getTouchDistance(t1, t2) {
        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function getTouchAngle(t1, t2) {
        return Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
    }

    function updateMouseFromTouch(touch) {
        const canvas = renderer.domElement;
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function updateGhostFromTouch() {
        if (!ghostBrick) return;
        if (!window.brickData) return;
        const info = window.brickData[state.selectedBrick];
        if (!info) return;

        raycaster.setFromCamera(mouse, camera);

        let hitPoint = null;
        // Check bricks first
        const brickMeshes = [];
        bricksGroup.traverse(child => { if(child.isMesh) brickMeshes.push(child); });
        const brickHits = raycaster.intersectObjects(brickMeshes);
        if (brickHits.length > 0) hitPoint = brickHits[0].point;
        // Then ground
        if (!hitPoint) {
            const groundHits = raycaster.intersectObject(groundPlane);
            if (groundHits.length > 0) hitPoint = groundHits[0].point;
        }

        if (hitPoint) {
            let gx = Math.floor(hitPoint.x / UNIT);
            let gz = Math.floor(hitPoint.z / UNIT);
            gx = Math.max(0, Math.min(31, gx));
            gz = Math.max(0, Math.min(31, gz));

            const w = info.width * UNIT;
            const d = info.depth * UNIT;
            const h = info.height * HEIGHT;

            // Swap width/depth for positioning when rotated 90¬∞ or 270¬∞
            const isRotated90 = (state.rotation === 90 || state.rotation === 270);
            const posW = isRotated90 ? d : w;
            const posD = isRotated90 ? w : d;

            const autoStack = getStackHeight(gx, gz);
            const effectiveLayer = state.manualLayerMode ? state.buildHeight : autoStack;
            const hasCollision = checkCollision(gx, gz, effectiveLayer);
            ghostBrick.position.set(gx * UNIT + posW/2, effectiveLayer * HEIGHT + h/2, gz * UNIT + posD/2);
            ghostBrick.rotation.y = (state.rotation * Math.PI) / 180;
            ghostBrick.material.color.setHex(hasCollision ? 0xff4444 : new THREE.Color(state.selectedColor).getHex());
            document.getElementById('cursor-pos').textContent = `X:${gx} Z:${gz} Layer:${effectiveLayer}${hasCollision ? ' (BLOCKED)' : ' (OK)'}`;
        }
    }

    function handleTap() {
        raycaster.setFromCamera(mouse, camera);

        if (touchMode === 'delete') {
            // Try to find a brick to delete
            const brickMeshes = [];
            bricksGroup.traverse(child => { if(child.isMesh) brickMeshes.push(child); });
            const intersects = raycaster.intersectObjects(brickMeshes);
            if (intersects.length > 0) {
                let parent = intersects[0].object.parent;
                while(parent && !parent.userData.id) parent = parent.parent;
                if (parent && parent.userData.id) {
                    removeBrick(parent.userData.id);
                    return;
                }
            }
            showToast('Tap on a brick to delete it', 'error');
            return;
        }

        if (touchMode === 'select') {
            // Try to select a brick
            const brickMeshes = [];
            bricksGroup.traverse(child => { if(child.isMesh) brickMeshes.push(child); });
            const intersects = raycaster.intersectObjects(brickMeshes);
            if (intersects.length > 0) {
                let parent = intersects[0].object.parent;
                while(parent && !parent.userData.id) parent = parent.parent;
                if (parent && parent.userData.id) {
                    selectPlacedBrick(parent.userData.id);
                    showToast(`Selected brick: ${parent.userData.type}`);
                    return;
                }
            }
            showToast('Tap on a brick to select it', 'error');
            return;
        }

        if (touchMode === 'place') {
            // Place at tap position ‚Äî check bricks first, then ground
            let hitPoint = null;
            const brickMeshes2 = [];
            bricksGroup.traverse(child => { if(child.isMesh) brickMeshes2.push(child); });
            const brickHits = raycaster.intersectObjects(brickMeshes2);
            if (brickHits.length > 0) hitPoint = brickHits[0].point;
            if (!hitPoint) {
                const groundHits = raycaster.intersectObject(groundPlane);
                if (groundHits.length > 0) hitPoint = groundHits[0].point;
            }
            if (hitPoint) {
                let gx = Math.floor(hitPoint.x / UNIT);
                let gz = Math.floor(hitPoint.z / UNIT);
                gx = Math.max(0, Math.min(31, gx));
                gz = Math.max(0, Math.min(31, gz));
                state.cursorX = gx;
                state.cursorZ = gz;

                // Handle all placement modes
                if (state.placementMode === 'preset' && state.presetData) {
                    placePresetAtCursor();
                    updateGhostPresetPosition();
                } else if (state.placementMode === 'minifig' && selectedMinifig) {
                    placeSelectedMinifig();
                    if (typeof updateGhostMinifig === 'function') updateGhostMinifig();
                } else {
                    placeBrick(gx, gz);
                }
                updateCursorPosition();
            }
        }
    }

    // ========== LONG PRESS (delete in place mode) ==========
    function startLongPress(touch) {
        longPressTimer = setTimeout(() => {
            longPressTriggered = true;

            // Check if we're long-pressing on a brick
            raycaster.setFromCamera(mouse, camera);
            const brickMeshes = [];
            bricksGroup.traverse(child => { if(child.isMesh) brickMeshes.push(child); });
            const intersects = raycaster.intersectObjects(brickMeshes);

            if (intersects.length > 0) {
                let parent = intersects[0].object.parent;
                while(parent && !parent.userData.id) parent = parent.parent;
                if (parent && parent.userData.id) {
                    removeBrick(parent.userData.id);
                    // Haptic feedback if available
                    if (navigator.vibrate) navigator.vibrate(50);
                }
            }
            removeLongPressIndicator();
        }, 600);

        // Show visual indicator
        showLongPressIndicator(touch.clientX, touch.clientY);
    }

    function clearLongPress() {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        removeLongPressIndicator();
    }

    function showLongPressIndicator(x, y) {
        removeLongPressIndicator();
        longPressIndicator = document.createElement('div');
        longPressIndicator.className = 'long-press-indicator';
        longPressIndicator.style.left = x + 'px';
        longPressIndicator.style.top = y + 'px';
        document.body.appendChild(longPressIndicator);
    }

    function removeLongPressIndicator() {
        if (longPressIndicator) {
            longPressIndicator.remove();
            longPressIndicator = null;
        }
    }

    // ========== DESKTOP RIGHT PANEL TOGGLE ==========
    function toggleRightPanel() {
        const app = document.querySelector('.app');
        const btn = document.getElementById('right-panel-toggle');
        app.classList.toggle('right-panel-hidden');
        if (app.classList.contains('right-panel-hidden')) {
            btn.textContent = '‚ñ∂';
            btn.title = 'Show Settings Panel';
        } else {
            btn.textContent = '‚óÄ';
            btn.title = 'Hide Settings Panel';
        }
        // Resize Three.js canvas after layout change
        setTimeout(() => { if (typeof onResize === 'function') onResize(); }, 350);
    }

    // ========== iPad PANEL MANAGEMENT ==========
    function togglePanel(side) {
        const leftPanel = document.querySelector('.left-panel');
        const rightPanel = document.querySelector('.right-panel');
        const backdrop = document.getElementById('panel-backdrop');
        const toggleLeft = document.getElementById('toggle-left-panel');
        const toggleRight = document.getElementById('toggle-right-panel');

        if (side === 'left') {
            const isOpen = leftPanel.classList.contains('panel-open');
            rightPanel.classList.remove('panel-open');
            toggleRight.classList.remove('active');

            if (isOpen) {
                leftPanel.classList.remove('panel-open');
                backdrop.classList.remove('visible');
                toggleLeft.classList.remove('active');
            } else {
                leftPanel.classList.add('panel-open');
                backdrop.classList.add('visible');
                toggleLeft.classList.add('active');
            }
        } else {
            const isOpen = rightPanel.classList.contains('panel-open');
            leftPanel.classList.remove('panel-open');
            toggleLeft.classList.remove('active');

            if (isOpen) {
                rightPanel.classList.remove('panel-open');
                backdrop.classList.remove('visible');
                toggleRight.classList.remove('active');
            } else {
                rightPanel.classList.add('panel-open');
                backdrop.classList.add('visible');
                toggleRight.classList.add('active');
            }
        }
    }

    function closeAllPanels() {
        document.querySelector('.left-panel').classList.remove('panel-open');
        document.querySelector('.right-panel').classList.remove('panel-open');
        document.getElementById('panel-backdrop').classList.remove('visible');
        document.getElementById('toggle-left-panel').classList.remove('active');
        document.getElementById('toggle-right-panel').classList.remove('active');
    }

    function showHeaderActions() {
        // Show header actions as a modal on iPad
        const actions = [
            { icon: '‚è™', label: 'Undo', fn: 'undoAction()' },
            { icon: '‚è©', label: 'Redo', fn: 'redoAction()' },
            { icon: 'ü™û', label: 'Mirror', fn: 'toggleMirrorMode()' },
            { icon: 'üìã', label: 'Copy', fn: 'duplicateSelected()' },
            { icon: 'üóëÔ∏è', label: 'Clear All', fn: 'clearScene()' },
            { icon: 'üíæ', label: 'Save', fn: 'saveDesign()' },
            { icon: 'üìñ', label: 'Instructions', fn: 'showInstructions()' },
            { icon: 'üìè', label: 'Measure', fn: 'showMeasurements()' },
            { icon: 'üí∞', label: 'Cost', fn: 'showCostEstimate()' },
            { icon: 'üì•', label: 'Import', fn: 'showImportDialog()' },
            { icon: 'üì∏', label: 'Screenshot', fn: 'takeScreenshot()' },
            { icon: 'üîÑ', label: 'Spin', fn: 'toggleTurntable()' },
            { icon: 'üîó', label: 'Share', fn: 'shareDesign()' },
            { icon: 'üì§', label: 'Export STL', fn: 'exportSTL()' },
            { icon: 'üì¶', label: 'Export 3MF', fn: 'exportFor3MF()' },
            { icon: 'üñ®Ô∏è', label: 'Bambu', fn: 'showBambuPanel()' },
            { icon: 'ü§ñ', label: 'AI', fn: 'showAIAssistant()' },
            { icon: 'üé¨', label: 'Animate', fn: 'playBuildAnimation()' },
            { icon: 'üèóÔ∏è', label: 'Physics', fn: 'checkStructure()' },
            { icon: 'üåç', label: 'Community', fn: 'showCommunity()' },
            { icon: 'üè¢', label: 'Building', fn: 'generateBuilding()' },
            { icon: 'üé≠', label: 'Decals', fn: 'showDecals()' },
            { icon: 'üìï', label: 'Manual', fn: 'generateInstructionBook()' },
            { icon: 'üñ®Ô∏è', label: 'Printers', fn: 'showPrinterHub()' },
            { icon: '‚ùì', label: 'Help', fn: 'showHelp()' },
        ];

        const html = `
            <div class="modal-overlay" onclick="if(event.target===this)this.remove()">
                <div class="modal" style="max-width:500px;">
                    <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">‚úï</button>
                    <h2>üîß Tools & Actions</h2>
                    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:16px;">
                        ${actions.map(a => `
                            <button class="btn" onclick="${a.fn};this.closest('.modal-overlay').remove();"
                                    style="flex-direction:column;padding:14px 8px;min-height:60px;justify-content:center;">
                                <span style="font-size:1.4em;">${a.icon}</span>
                                <span style="font-size:0.75em;">${a.label}</span>
                            </button>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', html);
    }

    // ========== ORBITCONTROLS TOUCH FIX ==========
    function fixOrbitControlsForTouch() {
        if (!controls || !isTouchDevice) return;

        // Configure OrbitControls for better touch behavior
        controls.touches = {
            ONE: THREE.TOUCH.ROTATE,   // One finger = orbit/rotate
            TWO: THREE.TOUCH.DOLLY_PAN // Two fingers = zoom/pan
        };

        // Enable smoother damping for touch
        controls.dampingFactor = 0.12;
        controls.rotateSpeed = 0.6;
        controls.panSpeed = 0.8;
        controls.zoomSpeed = 1.2;

        // Make sure touch events work with orbit controls
        controls.enableRotate = true;
        controls.enablePan = true;
        controls.enableZoom = true;
    }

    // ========== INIT ==========
    window.addEventListener('DOMContentLoaded', async () => {
        try {
            console.log('[INIT] Starting initThreeJS...');
            initThreeJS();
            console.log('[INIT] initThreeJS complete. Loading bricks...');
            await loadBricks();
            console.log('[INIT] Bricks loaded. Loading presets...');
            await loadPresets();
            await loadSavedDesigns();
            await loadTechnicParts();
            console.log('[INIT] All data loaded.');

            // Initialize touch support for iPad
            initTouchSupport();
            fixOrbitControlsForTouch();

            // Re-create cursor marker now that brickData is loaded
            createCursorMarker();

            // Initialize minifig character gallery
            initMinifigGrid();
            updateModeIndicator();

            const msg = isTouchDevice
                ? 'üß± 3D Designer ready! Tap to place bricks. Use toolbar below.'
                : 'üß± 3D Designer ready! Click to place bricks. Press ? for help.';
            showToast(msg, 'success');
        } catch (err) {
            console.error('[INIT ERROR]', err);
            // Show visible error banner on screen
            const banner = document.createElement('div');
            banner.style.cssText = 'position:fixed;top:0;left:0;right:0;background:red;color:white;padding:12px;z-index:99999;font-size:14px;font-family:monospace;';
            banner.textContent = 'Init Error: ' + err.message + ' | Stack: ' + (err.stack || '').substring(0, 200);
            document.body.appendChild(banner);
        }
    });

    // =============================================
    // COGNITO AUTHENTICATION
    // =============================================
    const COGNITO_CONFIG = {
        userPoolId: 'ap-northeast-1_qjgrtbzGz',
        clientId: '38rvjgcq9kukds2ft1s8c6mroc',
        domain: 'ea-guide-viewer-20251224125510.auth.ap-northeast-1.amazoncognito.com',
        region: 'ap-northeast-1',
        scopes: ['openid', 'email', 'profile'],
        redirectUri: window.location.origin + '/',
    };

    // Check if we're returning from Cognito login (authorization code in URL)
    function handleCognitoCallback() {
        const params = new URLSearchParams(window.location.search);
        const code = params.get('code');
        if (code) {
            // Exchange authorization code for tokens
            exchangeCodeForTokens(code);
            // Clean up URL
            window.history.replaceState({}, document.title, window.location.pathname);
        }
    }

    async function exchangeCodeForTokens(code) {
        try {
            const tokenUrl = `https://${COGNITO_CONFIG.domain}/oauth2/token`;
            const body = new URLSearchParams({
                grant_type: 'authorization_code',
                client_id: COGNITO_CONFIG.clientId,
                code: code,
                redirect_uri: COGNITO_CONFIG.redirectUri,
            });
            const resp = await fetch(tokenUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: body.toString(),
            });
            if (!resp.ok) {
                console.error('Token exchange failed:', resp.status);
                return;
            }
            const tokens = await resp.json();
            localStorage.setItem('cognito_id_token', tokens.id_token);
            localStorage.setItem('cognito_access_token', tokens.access_token);
            if (tokens.refresh_token) localStorage.setItem('cognito_refresh_token', tokens.refresh_token);
            localStorage.setItem('cognito_expires_at', String(Date.now() + tokens.expires_in * 1000));
            updateAuthUI();
        } catch (err) {
            console.error('Token exchange error:', err);
        }
    }

    function cognitoLogin() {
        const params = new URLSearchParams({
            client_id: COGNITO_CONFIG.clientId,
            response_type: 'code',
            scope: COGNITO_CONFIG.scopes.join(' '),
            redirect_uri: COGNITO_CONFIG.redirectUri,
        });
        window.location.href = `https://${COGNITO_CONFIG.domain}/login?${params.toString()}`;
    }

    function cognitoLogout() {
        localStorage.removeItem('cognito_id_token');
        localStorage.removeItem('cognito_access_token');
        localStorage.removeItem('cognito_refresh_token');
        localStorage.removeItem('cognito_expires_at');
        const params = new URLSearchParams({
            client_id: COGNITO_CONFIG.clientId,
            logout_uri: COGNITO_CONFIG.redirectUri,
        });
        window.location.href = `https://${COGNITO_CONFIG.domain}/logout?${params.toString()}`;
    }

    function getCognitoUser() {
        const idToken = localStorage.getItem('cognito_id_token');
        const expiresAt = parseInt(localStorage.getItem('cognito_expires_at') || '0');
        if (!idToken || Date.now() > expiresAt) return null;
        try {
            // Decode JWT payload (base64)
            const payload = JSON.parse(atob(idToken.split('.')[1]));
            return {
                email: payload.email || '',
                name: payload.name || payload['cognito:username'] || payload.email || 'User',
                sub: payload.sub,
                groups: payload['cognito:groups'] || [],
            };
        } catch (e) {
            return null;
        }
    }

    function updateAuthUI() {
        const section = document.getElementById('auth-section');
        const user = getCognitoUser();
        if (user) {
            const initials = (user.name || user.email || 'U').substring(0, 2).toUpperCase();
            const displayName = user.name || user.email;
            section.innerHTML = `
                <div class="user-badge" onclick="toggleUserMenu(event)">
                    <div class="user-avatar">${initials}</div>
                    <span class="user-name">${displayName}</span>
                    <div class="user-menu" id="user-menu">
                        <div class="user-menu-item" style="opacity:0.6;pointer-events:none;">
                            üìß ${user.email}
                        </div>
                        <div class="user-menu-divider"></div>
                        <div class="user-menu-item" onclick="showMyDesigns()">üìÅ My Designs</div>
                        <div class="user-menu-item" onclick="showMyProfile()">üë§ Profile</div>
                        <div class="user-menu-divider"></div>
                        <div class="user-menu-item danger" onclick="cognitoLogout()">üö™ Logout</div>
                    </div>
                </div>
            `;
        } else {
            section.innerHTML = `<button class="btn-login" onclick="cognitoLogin()">üîê Login</button>`;
        }
    }

    function toggleUserMenu(e) {
        e.stopPropagation();
        const menu = document.getElementById('user-menu');
        if (menu) menu.classList.toggle('show');
    }

    // Close user menu when clicking elsewhere
    document.addEventListener('click', () => {
        const menu = document.getElementById('user-menu');
        if (menu) menu.classList.remove('show');
    });

    function showMyDesigns() {
        const user = getCognitoUser();
        if (!user) return cognitoLogin();
        showToast('My Designs ‚Äî coming soon! Your saved designs will appear here.', 'info');
    }

    function showMyProfile() {
        const user = getCognitoUser();
        if (!user) return cognitoLogin();
        showToast(`Profile: ${user.name} (${user.email})`, 'info');
    }

    // Initialize auth on page load
    handleCognitoCallback();
    updateAuthUI();

    </script>
</body>
</html>
